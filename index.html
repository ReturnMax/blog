<!DOCTYPE html>
<html lang="zh">
    <head>
	<meta name="generator" content="Hugo 0.63.2" />
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>晨钟暮鼓</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="Gavin&#39;s Blog"><link rel="canonical" href="http://belldrum.com/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><link rel="alternate" href="/index.xml" type="application/rss+xml" title="晨钟暮鼓">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="晨钟暮鼓"><meta property="og:title" content="晨钟暮鼓" />
<meta property="og:description" content="Gavin&#39;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://belldrum.com/" />
<meta property="og:updated_time" content="2020-02-19T10:42:56+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="晨钟暮鼓"/>
<meta name="twitter:description" content="Gavin&#39;s Blog"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "http:\/\/belldrum.com\/","author": {
                "@type": "Person",
                "name": "Gavin"
            },"description": "Gavin\x27s Blog","image": "http:\/\/belldrum.com\/cover.png","thumbnailUrl": "http:\/\/belldrum.com\/logo.png","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","name": "晨钟暮鼓"
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/css/lib/animate/animate.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="http://belldrum.com/">晨钟暮鼓</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="http://belldrum.com/posts" title="">文章</a><a class="menu-item" href="http://belldrum.com/tags" title="">标签</a><a class="menu-item" href="http://belldrum.com/categories" title="">分类</a><a class="menu-item" href="http://belldrum.com/about" title="">关于</a><a class="menu-item" href="http://belldrum.com/" title="English">主页</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="http://belldrum.com/">晨钟暮鼓</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="http://belldrum.com/posts" title="">文章</a><a class="menu-item" href="http://belldrum.com/tags" title="">标签</a><a class="menu-item" href="http://belldrum.com/categories" title="">分类</a><a class="menu-item" href="http://belldrum.com/about" title="">关于</a><a class="menu-item" href="http://belldrum.com/" title="English">主页</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><div class="page"><div class="home-intro"><div class="home-avatar">
            <a href="/posts">
                <img src=/images/avatar.png alt="avatar" title="主页">
            </a>
        </div><h2 class="home-description"><div id=rtp-1bf8abddf514ac940e9ba88fb259fd6a hidden=true>悟已往之不谏，知来者之可追</div>
            <div id=tp-1bf8abddf514ac940e9ba88fb259fd6a class="typeit"></div></h2><div class="home-social-links"><a href="https://github.com/xxxx" rel="me noopener noreffer" target="_blank">
        <i class="fab fa-github-alt fa-fw" title="Github"></i>
    </a><a href="https://linkedin.com/in/xxxx" rel="me noopener noreffer" target="_blank">
        <i class="fab fa-linkedin fa-fw" title="LinkedIn"></i>
    </a>
    <a href="mailto:xxxx@outlook.com" rel="me noopener noreffer">
        <i class="far fa-envelope fa-fw" target="_blank" title="Email"></i>
    </a></div>
</div>
<article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0000-markdown-syntax/">Markdown Syntax</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>Gavin
        </a>发布于  <time datetime=2020-02-19>2020-02-19</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/markdown/">Markdown</a></span></div><div class="post-content"><p>本文主要收集了一些关于Markdown语法的魔法知识 😂
<br /></p>
<a class="post-dummy-target" id="空格"></a><h2>空格</h2>
<p><code>&amp;ensp;</code>半角空格以及<code>&amp;emsp;</code>全角空格</p>
<a class="post-dummy-target" id="表格内换行"></a><h2>表格内换行</h2>
<table>
<thead>
<tr>
<th align="left">Header 1</th>
<th align="left">Header 2</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">item</td>
<td align="left">1. one<br />2. two<br />3. three</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="页面内跳转"></a><h2>页面内跳转</h2>
<p><a href="#%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a">跳转到可爱</a></p>
<a class="post-dummy-target" id="任务列表"></a><h2>任务列表</h2>
<ul>
<li><i class="far fa-check-square fa-fw"></i>  唱跳</li>
<li><i class="far fa-square fa-fw"></i>  Rap</li>
</ul>
<a class="post-dummy-target" id="添加emoji"></a><h2>添加Emoji</h2>
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank">👻</a></p>
<a class="post-dummy-target" id="添加注释"></a><h2>添加注释</h2>
<ruby>
<rb>刘畅</rb><rt>so cute</rt>
</ruby>
<a class="post-dummy-target" id="键盘按键"></a><h2>键盘按键</h2>
<kbd>
	<kbd>Ctrl</kbd>
	+
	<kbd>D</kbd>
</kbd>
<a class="post-dummy-target" id="继续补充中"></a><h2>继续补充中&hellip;</h2></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0000-markdown-syntax/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/markdown/"><i class="fas fa-tag fa-fw"></i>&nbsp;Markdown</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0005-linux-user-management/">Linux文件与用户管理</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>Gavin
        </a>发布于  <time datetime=2020-02-16>2020-02-16</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/linux/">Linux</a></span></div><div class="post-content"><p>Linux系统是一个多用户多任务的分时操作系统，每一个需要使用系统资源的用户都需要先由系统管理员创建一个账号，然后以该账号的身份和口令登入系统。</p>
<p>用户的账号既有助于系统管理员控制用户对系统资源的访问权限，也有助于帮助用户组织文件，并为用户提供安全性、隐私性的保护。</p>
<a class="post-dummy-target" id="文件基本属性"></a><h2>文件基本属性</h2>
<p>在学习Linux用户管理之前，我们先来了解关于文件的一些基本概念。<br>
在Linux系统中有一个基本思想，即“一切皆文件”。控制文件的访问权限非常重要，Linux中针对每一个文件都有属主(User/Owner)、属组(Group)和其他组(Other)的概念，藉此可以管理不同用户访问同一文件的权限。<br>
<br />
在Linux系统中，我们可以使用<code>ls -l</code>命令来显示一个文件的属性及其所属的用户和组，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@guoc:/# ls -l
total <span class="m">7</span>
...
drwxrw-r-- <span class="m">1</span> root root <span class="m">4096</span> Otc <span class="m">18</span> <span class="m">2020</span> bin  
----------   ---- ----                  ---
 类型及权限   属主  属组                 文件
...
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="属性"></a><h3>属性</h3>
<p>首字段<code>drwxrw-r--</code>描述了文件的类型及不同用户的权限(Permission)。</p>
<table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">属主权限</th>
<th align="center">属组权限</th>
<th align="center">其他用户权限</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">d</td>
<td align="center">r w x</td>
<td align="center">r w -</td>
<td align="center">r - -</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1 2 3</td>
<td align="center">4 5 6</td>
<td align="center">7 8 9</td>
</tr>
<tr>
<td align="center">目录文件</td>
<td align="center">读写执行</td>
<td align="center">读写</td>
<td align="center">读</td>
</tr>
</tbody>
</table>
<p>其中，首字符表示文件类型：<br>
<code>d</code>为目录，<code>-</code>为文件，<code>l</code>为链接文档，<code>b</code>为可供存储的接口设备，<code>c</code>为串行端口设备。</p>
<p>接下来的字符中，<code>rwx</code>三个一组，分别表示<code>read</code>、<code>write</code>和<code>execute</code>权限，<code>-</code>表示没有对应的权限。</p>
<p>总体来看，第0位确定文件类型，第1-3位确定属主拥有该文件的权限，
第4-6位确定属组拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<a class="post-dummy-target" id="属主userowner"></a><h3>属主(User/Owner)</h3>
<p>属主是文件的所有者。默认情况下，属主为该文件的创建者，谁创建了这个文件，谁就自然的成为了该文件的所有者。</p>
<a class="post-dummy-target" id="属组group"></a><h3>属组(Group)</h3>
<p>在Linux系统中，用户是按组分类的，一个用户属于一个或多个组，属于同一个组的用户对同一文件拥有相同的访问权限。<br>
当一个用户创建了一个文件后，默认该用户所在的组就是这个文件的属组。通过设定文件的属组，我们可以集中管理属组内所有用户对这个文件的访问权限。</p>
<p><strong>注意：</strong></p>
<ol>
<li>默认情况下，文件的属主和属组分别为该文件的创建者及其所在的用户组，但我们也可以更改文件的属主和属组。因此，一些教程中把文件的属组解释为文件属主所在的组，或者把属组用户解释为与属主同组的用户，这种理解并不正确。</li>
<li>上面的例子中，虽然属主和属组都为root，但是属主字段为<strong>用户</strong><code>uid</code>，属组字段为<strong>用户组</strong><code>gid</code>，前者代表单个用户账号，后者代表账号的集合。我们在创建新用户时，会默认创建一个同名的用户组，但是两者之间并不等价。</li>
<li>对每一个文件来说，除属主以外的用户再划分为属组用户和其他用户，三者之间的权限彼此独立。比如：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">d---rw-r-- <span class="m">1</span> usr usr <span class="m">4096</span> Otc <span class="m">18</span> <span class="m">2020</span> bin
</code></pre></td></tr></table>
</div>
</div><p>假设属主usr的gid为usr，此时属主没有读写执行bin文件的权限，但是与属主同组的其他用户拥有读写bin文件的权限。</p>
</li>
</ol>
<a class="post-dummy-target" id="其他组other"></a><h3>其他组(Other)</h3>
<p>除去文件属主和属组用户以外的用户为其他组用户。</p>
<a class="post-dummy-target" id="文件属性管理"></a><h2>文件属性管理</h2>
<a class="post-dummy-target" id="更改文件属主"></a><h3>更改文件属主</h3>
<p><strong>Root用户</strong>可以使用<code>chown</code>命令更改文件的属主，也可以同时更改文件的属组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chown <span class="o">[</span>-R<span class="o">]</span> User<span class="o">[</span>:Group<span class="o">]</span> <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>[  ]</code>内为可选参数。<br>
-R 为递归更改，当更改目录文件时，加上该参数可以递归更改目录及目录下所有文件的属主。</p>
<a class="post-dummy-target" id="更改文件属组"></a><h3>更改文件属组</h3>
<p><strong>Root用户</strong>和<strong>文件属主</strong>可以使用<code>chgrp</code>命令更改文件属组，前者更改没有限制，后者只可将属组改为自己是其成员的组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chgrp <span class="o">[</span>-R<span class="o">]</span> User <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>-R 为可选参数。当更改目录文件时，加上该参数可以递归更改目录及目录下所有文件的属组。</p>
<a class="post-dummy-target" id="更改文件权限"></a><h3>更改文件权限</h3>
<p><strong>Root用户</strong>和<strong>文件属主</strong>可以使用<code>chmod</code>命令更改文件权限。<br>
更改文件权限有两种方式，分别为数字模式(Numeric Mode)和符号模式(Symbolic Mode)。</p>
<a class="post-dummy-target" id="数字模式"></a><h4>数字模式</h4>
<p>数字模式中<code>r``w``x</code>权限分别用分数表示：</p>
<ul>
<li><code>r</code>：4</li>
<li><code>w</code>：2</li>
<li><code>x</code>：1</li>
</ul>
<p>三种权限的分数累加之和代表User、Group和Other用户的权限。举个例子，<code>[-rwxrw----]</code>分数计算如下：</p>
<ul>
<li><code>User = rwx = 4 + 2 + 1 = 7</code></li>
<li><code>Group = rw- = 4 + 2 + 0 = 6</code></li>
<li><code>Other = --- = 0 + 0 + 0 = 0</code></li>
</ul>
<p>因此，该文件的权限数字可以用<code>760</code>表示。<br>
更改权限的时我们输入如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod <span class="o">[</span>-R<span class="o">]</span> xyz <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中xyz就是按照上述方法计算出的用户权限。</p>
<a class="post-dummy-target" id="符号模式"></a><h4>符号模式</h4>
<p>符号模式中使用<code>u</code>，<code>g</code>，<code>o</code>分别表示<code>User</code>，<code>Group</code>，<code>Other</code>，用<code>a</code>来表示<code>All</code>，即全部的身份。此外，使用<code>+</code>，<code>-</code>，<code>=</code>分别表示添加、除去和设定权限。</p>
<p>举个例子，我们设定<code>test</code>文件的权限为<code>-rwxr-xr--</code>，可以使用以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod <span class="nv">u</span><span class="o">=</span>rwx,g<span class="o">=</span>rx,o<span class="o">=</span>r <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><p>现在我们使用以下命令，除去<code>test</code>文件所有用户的执行权限：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod a-x <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="用户管理"></a><h2>用户管理</h2>
<p>Linux是一个多用户的操作系统，支持多个用户同时登录。用户角色可分为三类，分别为root用户、伪用户和普通用户。<br>
<br />
Root用户系统唯一，具有系统的最高权限，可以操作任何的文件和命令。<br>
伪用户是系统运行必不可少的用户，比如bin、daemon、adm、ftp、mail等用户。这些用户通常都是系统自身拥有的，不具备登录系统的能力。<br>
普通用户和root用户一样，都是真实用户，可以登录系统。但是普通用户的权限有限，通常都是由系统管理员自行添加。<br>
<br />
用户账号的管理主要涉及到用户账号的添加、修改和删除，我们来分别介绍这几部分的内容。</p>
<a class="post-dummy-target" id="添加新用户账号"></a><h3>添加新用户账号</h3>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。<br>
通过使用<code>useradd</code>命令添加新的用户账号，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">useradd <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-c</code> comment 指定一段注释性描述</li>
<li><code>-d</code> 指定用户主目录，如果此目录不存在，添加-m选项可以创建主目录</li>
<li><code>-g</code> 指定用户所属的用户组 </li>
<li><code>-G</code> 指定用户所属的附加组，有多个附加组则用逗号隔开</li>
<li><code>-s</code> 指定用户的登录Shell</li>
<li><code>-u</code> 指定用户的用户号</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">useradd -d /home/gavin -m -s /bin/bash -g group -G root,adm gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令添加了一个名为<code>gavin</code>的新用户，<code>-d</code>和<code>-m</code>选项为该用户创建了主目录<code>/home/gavin</code>，登录shell为<code>bash</code>，他属于<code>group</code>用户组，同时也属于<code>root</code>和<code>adm</code>用户组，其中<code>group</code>是他的主用户组。<br>
<br />
添加新用户账号就是系统在/etc/passwd文件中增加一条新纪录，同时更新其他系统文件，如/etc/group和/etc/shadow等，详细介绍见第五节<a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%94%a8%e6%88%b7%e7%bb%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">「用户和用户组配置文件」</a>。</p>
<a class="post-dummy-target" id="指定或修改用户密码"></a><h3>指定或修改用户密码</h3>
<p>刚创建的用户没有密码，被系统锁定无法使用，需要为其指定密码后才可以使用，即使是指定空的密码。<br>
使用<code>passwd</code>命令指定或修改用户密码，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">passwd <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-l</code> 锁定密码，禁用账号</li>
<li><code>-u</code> 密码解锁</li>
<li><code>-d</code> 使账号没有密码</li>
<li><code>-f</code> 强迫用户下次登录时修改密码</li>
<li>如果username为空，则默认修改当前用户的密码</li>
</ul>
<a class="post-dummy-target" id="修改用户"></a><h3>修改用户</h3>
<p>修改用户账号就是根据实际业务需求更改用户的相关书信，如用户组、登录Shell等。<br>
使用<code>usermod</code>命令修改用户属性，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">usermod <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-l newname</code> 修改用户名</li>
<li>其它可参考<code>useradd</code>命令，如<code>-d</code>，<code>-g</code>，<code>-a -G</code>，<code>-s</code>。</li>
</ul>
<a class="post-dummy-target" id="删除用户"></a><h3>删除用户</h3>
<p>我们可以使用<code>userdel</code>命令执行删除用户的操作，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">userdel <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>常用的选项是<code>-r</code>，它的作用是将该用户的主目录一起删除，不添加的话会保留该用户的主目录。<br>
举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">userdel -r gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令会删除用户<code>gavin</code>在系统文件，如/etc/passwd，/etc/shadow，/etc/group中的相应记录，同时删除用户的主目录。</p>
<a class="post-dummy-target" id="用户组管理"></a><h2>用户组管理</h2>
<p>用户组是具有相同权限的一组用户，通过用户组我们可以集中管理用户组中所有用户的权限。<br>
默认情况下，Linux系统中创建的用户属于与它同名的用户组，这个用户组在创建用户时同时建立。<br>
用户组的管理主要包括用户组的添加、删除和修改，本质上是对/etc/group文件的更新。</p>
<a class="post-dummy-target" id="增加用户组"></a><h3>增加用户组</h3>
<p>使用<code>groupadd</code>命令增加新的用户组，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupadd <span class="o">[</span>-g<span class="o">]</span> groupname
</code></pre></td></tr></table>
</div>
</div><p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupadd -g <span class="m">100</span> gavin
</code></pre></td></tr></table>
</div>
</div><p>我们在系统中添加了一个名为<code>gavin</code>的新用户组，并指定新组的组标识号gid为100；如果不添加-g参数，那么新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<a class="post-dummy-target" id="修改用户组"></a><h3>修改用户组</h3>
<p>修改用户组属性使用<code>groupmod</code>命令，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupmod <span class="o">[</span>option<span class="o">]</span> group
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-g</code> 为用户指定新的组标识号</li>
<li><code>-n newgroup</code> 将用户组名改为新名字<br>
举个例子：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupmod -g <span class="m">2020</span> -n kavin gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令将gavin用户组更名为kavin，并将组标识号改为2020。</p>
<a class="post-dummy-target" id="删除用户组"></a><h3>删除用户组</h3>
<p>删除用户组使用<code>groupdel</code>命令，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupdel group
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="用户和用户组配置文件"></a><h2>用户和用户组配置文件</h2>
<p>在Linux系统中，与用户和用户组相关的信息保存在一些系统文件中，主要包括以下三个文件:</p>
<ul>
<li><code>/etc/passwd</code></li>
<li><code>/etc/group</code></li>
<li><code>/etc/shadow</code></li>
</ul>
<p>而前文所述的针对用户与用户组的管理，本质上是对这些文件中的相应信息进行修改，接下来让我们详细介绍一下这几个文件。</p>
<a class="post-dummy-target" id="passwd文件"></a><h3>passwd文件</h3>
<p><code>/etc/passwd</code>文件存储了当前系统中所有用户的信息。文件的每一行记录都对应着系统中的一个用户，记录了这个用户的一些基本属性。</p>
<p>文件的内容类似于下面的例子：</p>
<pre>
root&#58;x:0:0:root:/root:/bin/bash  
daemon&#58;x:1:1:daemon:/usr/sbin:/usr/sbin/nologin  
bin&#58;x:2:2:bin:/bin:/usr/sbin/nologin  
sys&#58;x:3:3:sys:/dev:/usr/sbin/nologin  
···
</pre>  
<p>文件中每个用户的信息格式是固定的，每行记录用（:）分隔为七个字段，每个字段的说明如下：</p>
<table>
<thead>
<tr>
<th align="center">user:</th>
<th align="center">x:</th>
<th align="center">123:</th>
<th align="center">456:</th>
<th align="center">xxx:</th>
<th align="center">/home/user:</th>
<th align="center">/bin/bash</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">用户名</td>
<td align="center">密码占位符</td>
<td align="center">UID</td>
<td align="center">GID</td>
<td align="center">注释性描述</td>
<td align="center">主目录</td>
<td align="center">登录Shell</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="shadow文件"></a><h3>shadow文件</h3>
<p>由于/etc/passwd文件所有用户都可读，用户的密码太简单或规律比较明显会被轻易破解。因此Linux系统中把加密后的密码分离出来，单独保存放在<code>/etc/shadow</code>文件中。只超级用户才拥有该文件的读取权限，保证了用户密码的安全性。</p>
<p>shadow文件中的记录与passwd中的用户记录一一对应，记录格式也类似，由（:）分割成的多个字段组成。</p>
<p>举个例子：</p>
<pre>
root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::  
</pre>
<p>字段说明如下：</p>
<p><code>登录名:加密密码:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></p>
<a class="post-dummy-target" id="group文件"></a><h3>group文件</h3>
<p>用户和用户组之间存在一对一、一对多和多对一的关系。<br>
在<code>passwd</code>文件中记录的是用户所属的主组，即登录时所属的默认组。除主组以外，用户也可以属于其他多个组，这些组称为用户的附加组。<br>
用户组的信息保存在<code>/etc/group</code>文件中，文件内容的格式与<code>passwd</code>相似，也是由（:）隔开的字段组成，举个例子：</p>
<pre>
root&#58;x:0:root
bin&#58;x:2:root,bin
sys&#58;x:3:root,uucp
···
gavin&#58;x:5:gavin,kavin 
</pre>  
<p>各个字段的说明如下：<br>
<code>组名:密码:组标识号(GID):组内用户列表</code></p>
<p>此外，用户组也有一个对应的<code>/etc/gshadow</code>文件保存用户组密码，在此不作具体介绍。</p>
<a class="post-dummy-target" id="常用命令总结"></a><h2>常用命令总结</h2>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>chmod [option] file</code></td>
<td align="left">修改文件权限</td>
</tr>
<tr>
<td align="left"><code>chown user file</code></td>
<td align="left">修改文件属主</td>
</tr>
<tr>
<td align="left"><code>chgrp group file</code></td>
<td align="left">修改文件属组</td>
</tr>
<tr>
<td align="left"><code>whoami</code></td>
<td align="left">查询当前登录用户名</td>
</tr>
<tr>
<td align="left"><code>id user</code></td>
<td align="left">查询指定用户信息，包括<code>uid</code>、<code>gid</code>和<code>groups</code><br />如果不指定用户名则显示当前登录用户信息</td>
</tr>
<tr>
<td align="left"><code>groups user</code></td>
<td align="left">查询指定用户所属的组，显示的第一个组是当前用户的主要组<br />如果不指定用户名则显示当前登录用户所属的组</td>
</tr>
<tr>
<td align="left"><code>newgrp group</code></td>
<td align="left">如果用户同时属于多个用户组，该命令用于当前登录用户在不同组间切换，<br/>以便具有其他用户组的权限，切换的组必须是当前用户的主组或附加组</td>
</tr>
<tr>
<td align="left"><code>su user</code></td>
<td align="left">切换登录用户，不指定用户名则切换为root用户<br />切换后$表示普通用户，#表示超级用户</td>
</tr>
<tr>
<td align="left"><code>useradd [option] user</code></td>
<td align="left">添加新用户</td>
</tr>
<tr>
<td align="left"><code>passwd [option] user</code></td>
<td align="left">指定或修改用户密码，添加新用户后需指定密码后才可使用</td>
</tr>
<tr>
<td align="left"><code>usermod [option] user</code></td>
<td align="left">修改用户信息</td>
</tr>
<tr>
<td align="left"><code>userdel [-r] user</code></td>
<td align="left">删除指定用户，-r删除用户主目录</td>
</tr>
<tr>
<td align="left"><code>groupadd group</code></td>
<td align="left">添加新用户组</td>
</tr>
<tr>
<td align="left"><code>groupdel group</code></td>
<td align="left">删除指定用户组</td>
</tr>
<tr>
<td align="left"><code>groupmod group</code></td>
<td align="left">修改指定用户组</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="细节补充"></a><h2>细节补充</h2>
<ol>
<li>
<p>添加新用户后，切换到该用户只显示一个<code>$</code>符号，而不是常见的<code>user@***</code>的格式；而且一些命令，如<code>ll</code>也无法使用，请问为什么？</p>
<p>解决办法：将用户登录Shell设置为/bin/bash即可。</p>
</li>
<li>
<p>从权限高的用户切换到权限低的用户不需要输入密码，反之需要。</p>
</li>
</ol>
<a class="post-dummy-target" id="参考资料"></a><h2>参考资料</h2>
<ol>
<li><a href="https://www.runoob.com/linux/linux-user-manage.html" target="_blank">菜鸟教程</a></li>
</ol></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0005-linux-user-management/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/linux/"><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0004-ssh-introduction/">SSH简介</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>Gavin
        </a>发布于  <time datetime=2020-02-12>2020-02-12</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/linux/">Linux</a></span></div><div class="post-content"><p>虽然一直在使用SSH连接服务器，但是对于SSH连接的原理却没有深究，只是大体了解是使用了非对称加密技术对传输信息进行了加密。搜资料的时候顺手翻到了一篇博文，介绍的还比较详细，特转载保存。本文转自<a href="https://fancyseeker.github.io/2013/12/30/ssh_overview/" target="_blank">链接</a>，作者是FancySeeker。<br>
本文主要介绍了SSH的连接认证原理以及SSH的配置和使用。</p>
<a class="post-dummy-target" id="ssh简要介绍"></a><h2>SSH简要介绍</h2>
<p>SSH的英文全称为Secure Shell，是IETF（Internet Engineering Task Force）的Network Working Group所制定的一族协议，其目的是要在非安全网络上提供安全的远程登录和其他安全网络服务。用于在主机之间建立起安全连接, 并加密传输内容, 以达到安全的远程访问, 操作以及数据传输的目的。</p>
<p>SSH主要有两个特点: 1. 安全性 2. 传输速度快</p>
<p>为什么要强调SSH的安全特性, 因为传统的网络服务程序，如 FTP、POP 和 Telnet 其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。 而 SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。透过 SSH 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗。</p>
<p>SSH的传输速度快是因为SSH传输的数据都是经过压缩的, 自然传输速度快。</p>
<a class="post-dummy-target" id="ssh认证原理"></a><h2>SSH认证原理</h2>
<p>在介绍SSH具体的认证原理之前, 先简单的介绍下关于公钥和密钥加密的概念。所谓的公钥加密（public-key cryptography），或非对称密钥加密（asymmetric key cryptography） 是一类广泛使用的加密算法。这类算法使用一对（pair）密钥即公钥（public key）和私钥（private key）。 其中公钥可以随便分发，只用于加密（encryption），私钥则只由一人持有，只用于解密。通过公钥加密过的密文使用密钥可以轻松解密, 但根据公钥来猜测私钥却十分困难。</p>
<p>因此, 我们可以很容易的发现这么一个事实, 一个消息在用公钥加密后, 哪怕在传输中被人截获, 如果没有私钥, 是无法解密获得其内容的, 只有拥有私钥的人才能成功解密消息。所以私钥应该由消息的接收方紧紧攥在手里, 不应让他人得知。</p>
<p>公钥加密的关键点在于，一方面，公钥加密是可逆的，但是不能用公钥推断出私钥。显然数学上，已知一个公钥是能够算出对应私钥的，但是只要设计足够好的加密算法（以及使用足够复杂的密钥对），使得不能在可以接受的时间内破译即可。</p>
<p>RSA是一种常见的公钥加密算法。RSA的工作原理依赖于如下事实：破译RSA私钥需要对某些极大的整数进行因数分解，而目前尚未找到快速的对极大整数作因数分解的算法。换言之，如果有人找到了这样的算法，那么全世界的 RSA 加密都会失效。</p>
<p>RSA是由Ron Rivest，Adi Shamir, Leonard Adleman三人在1978年首次提出的。三人并因此项工作荣获了2002年Turing Award。Rivest还是算法导论的作者之一，书中在31章对RSA系统的原理进行了简要说明，系统实现中利用到了数论中的Euler-Fermat theorem。</p>
<p>一个基于RSA的公钥大概如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAvSkEZ0fKXRqQ/DkjCfsAETsQgV8OR/RVQmwBk/J5IWoknf8Dr
y5kOs+1bnx9zaf8oIcVuXf0jRxTccLBOXiReFJE4aD2rWO33sqA0M4qP1ESYhsU4yokRA0IMDJ62JUv2cWVJg
GpeQriol2t7mH8E6aB8OiJ+NgRbh6+/0LbtQs40VA2+W5PtaBwT4sjv9LOHIdzQcsEeCM8MIHqmXHst7/JuVI
i7wLCxB7Ur8qtwZ2/Ii8Ckjfo6mikWmSh6mRMq9qn0FkMkPCcpm8o4f1zJWOuf+RnjPpopFTqIa8JssMHJMuQ
cCm3EHDkBHjLk/SkidWOzqOtSvUeGKieWiijuw== username@localhost.localdomain
</code></pre></td></tr></table>
</div>
</div><p>与之配对的私钥形如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAvSkEZ0fKXRqQ/DkjCfsAETsQgV8OR/RVQmwBk/J5IWoknf8D
ry5kOs+1bnx9zaf8oIcVuXf0jRxTccLBOXiReFJE4aD2rWO33sqA0M4qP1ESYhsU
4yokRA0IMDJ62JUv2cWVJgGpeQriol2t7mH8E6aB8OiJ+NgRbh6+/0LbtQs40VA2
+W5PtaBwT4sjv9LOHIdzQcsEeCM8MIHqmXHst7/JuVIi7wLCxB7Ur8qtwZ2/Ii8C
kjfo6mikWmSh6mRMq9qn0FkMkPCcpm8o4f1zJWOuf+RnjPpopFTqIa8JssMHJMuQ
cCm3EHDkBHjLk/SkidWOzqOtSvUeGKieWiijuwIBIwKCAQEAjITesx9jIJdkY5go
qFQOrbbZD6Wy1l27ra9RoRqF3k7ZX2z7bDEXQaGcuHm8iiUEzwVDVpOfuUg9/LyP
icdHffP4p5wk9dUMPxoWjHvk3pP/BwzNsBCtOd3LkYSVxXYji9SaroTkS0nqL3jK
WVAaV72FGVxJPINAJer0SJgQ7OJ7f0kZJYoPwG0VpMTLOsmulH7/M5e9i+kwDLmH
+TMvJ3y8gXjc/Sj5UqN/JQIY+h07UxYGvoju/isqFHh8OmahsjJ3Nb3QsUEkC/Kj
cKG2K+mUzTe/4/XQuqMadrjX82QF2b2gL+cdvUAwLn55boXmrtUzxEPo4xxiDNzY
AbYxSwKBgQDxIkaa+EPSJXYej/5YzJLJLVsnb9ygqe/0fM0x022J6Z+0Yq9AIwJ7
N7dvMgNSROLoJ17Oij/N7aoiAZy1KHg1vOoqx6T6BClay8I1+dOsbY6Fi0QbkZeI
Rr6CDueq5PBR8j/oghNhQeFfJUEICBFU6Z7+uFwxuAtQqqdFHyDhSwKBgQDI0nX6
Jz9oW+Y+dXAvhpL8Yln0R45ufiqatkTQgGbeZ70XlKeR7VzQiXecy/XDteJCMlnv
4BhjHL967nSAmrCza13I3eXIYxbzypeNC57bVVXM9BBTg5f4nWwTN+I8Gd/BA5Y8
mekQPBuSyAOp7ULAecjKZrD9Jhw1vybT/aYxUQKBgQDcdxv7ZqRoXMPEK+E7PrIX
BOWgZkYPPEkaC7RKz+8fAXwSo15mhmirK6BlqhGqTZxB+BwqjQcirWhZmxLuxeo/
wqo1vdiqEm7z7X5dPC8+kA1G5bqc3OJQtbV+OYNaaupZjQc6+pVgPDvEtFi24s4E
fdMyB6S/vjY7H67gHHXVSwKBgQC3m9mUQSQHpHq8wyS9vN4olG+AQWxHw88uXYC+
oUgbzI+gh+mp/ZawCKff0GurnvrALgkV1DON0SQYn4B1lL7P7SKLw5BCLrXmNZHg
Cp/eeegL19RpnOK3a1t/SQlbhV7cWw0ENPJX/HD7OocBwvszoouxvPmW/kWte5E2
</code></pre></td></tr></table>
</div>
</div><p>SSH 连接是<code>C/S</code>模型，客户端发出连接申请，服务器对客户端进行验证，再考虑是否接受连接申请。</p>
<a class="post-dummy-target" id="ssh认证过程"></a><h2>SSH认证过程</h2>
<p>SSH提供了两种认证的方式, 分别为:</p>
<a class="post-dummy-target" id="password认证"></a><h3>Password认证</h3>
<p>即账号口令验证，SSH的实现方式是，</p>
<ol>
<li>客户端向 ssh 服务器发出请求，服务器将自己的公钥返回给客户端；</li>
<li>客户端用服务器的公钥加密自己的登录密码，再将信息发送给服务器；</li>
<li>服务器接收到客户端传送的密码，用自己的私钥解码，如果结果正确，则同意登录，建立起连接。</li>
</ol>
<p>这种方式还是存在漏洞，中间人可以假扮成服务器，骗取客户端的密码。而且在每次登陆的时候都需要输入密码，所以一般不采用该验证方式。</p>
<a class="post-dummy-target" id="public-key认证"></a><h3>Public Key认证</h3>
<p>Public Key认证利用公钥私钥对进行认证，在请求连接时不需要输入密码，并且由于整个请求连接和通信过程全程加密，因此安全性高。<br>
SSH协议第二版中有RSA和DSA两种算法认证，其中RSA加密验证比较常用。<br>
RSA加密验证方式，充分利用了非对称加密体系的优势，不需要在网络传输密码，完全杜绝了中间人攻击的可能。<br>
认证的具体步骤如下:</p>
<ul>
<li><strong>准备工作</strong></li>
</ul>
<ol>
<li>客户端先使用 ssh-keygen 命令，生成公钥和私钥。按照默认配置，私钥会被保存在<code>~/.ssh/id_rsa</code>中，公钥则在<code>~/.ssh/id_rsa.pub</code>中。</li>
<li>客户端通过安全的方式（一般通过scp/Secure Copy Protocol）方式或者U盘拷贝的方式)将公钥发送给服务器。在服务器端, 将客户端发的公钥写入到<code>~/.ssh/authorized_keys</code>文件末尾。（其实公钥和私钥不是必须在客户端生成, 在服务器端生成也是可以的, 在哪生成的对公钥和私钥并没有任何影响, 重要的是二者是配对的, 而准备阶段其实是要保证这么一个事实, 即服务器端握有公钥, 并在对应账户的家目录下的<code>.ssh/authorized_keys</code>文件中保存以便验证程序访问。请求端握有私钥。 至于为什么要将公钥和私钥这么分配, 接下来将会解释）</li>
</ol>
<ul>
<li><strong>建立连接</strong><br>
在建立连接的时候，涉及到2对密钥，其中一对为准备阶段产生并分配好的密钥对，另一对为服务器在接收到一个连接请求时生成的密钥对。为了讲述方便，我们将这两组密钥对表示如下<br>
|Symbol|Description|<br>
|:-:|:-:|<br>
|PubC|客户端密钥对应的公钥|<br>
|PrvC|客户端握有的私钥|<br>
|PubS|服务器端产生的公钥|<br>
|PrvS|服务器端产生的私钥|</li>
</ul>
<ol>
<li>
<p><strong>认证</strong></p>
<ol>
<li>服务器生成随机数（称之为challenge）<code>x</code>，并用<code>PubC</code>加密后生成结果<code>s(x)</code>，发送给客户端；</li>
<li>客户端使用<code>PrvC</code>解密<code>s(x)</code>得到<code>x</code>，再将<code>x</code>用<code>PubS</code>加密发送回服务器端；</li>
<li>服务器端使用<code>PrvS</code>解密得到<code>x</code>，进行核对, 如果正确则链接正式成立。</li>
</ol>
</li>
<li>
<p><strong>通信加密</strong><br>
在请求连接前，服务器端和客户端拥有的密钥为<br>
|Server|Client|<br>
|:-:|:-:|<br>
|PubC|PrvC|</p>
<ol>
<li>客户端发出申请。服务器会产生一组<code>session</code>密钥对，即<code>PubS</code>和<code>PrvS</code>。<br>
此时服务器端和客户端拥有的密钥如下<br>
|Server|Client|<br>
|:-:|:-:|<br>
|PubC|PrvC|<br>
|PubS||<br>
|PrvS||</li>
<li>服务器端利用客户端的公钥<code>PubC</code>对<code>session</code>公钥<code>PubS</code>进行加密后发送给客户端；</li>
<li>客户端用自己的密钥<code>PrvC</code>解密信息，得到<code>session</code>公钥<code>PubS</code>，此时服务器端和客户端拥有的密钥如下<br>
|Server|Client|<br>
|:-:|:-:|<br>
|PubC|PubS|<br>
|PubS|PrvC|<br>
|PrvS||</li>
<li>之后的数据交互，都通过对方方公钥加密，对方收到信息后，用其私钥解密，实现安全加密过程。</li>
</ol>
</li>
</ol></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0004-ssh-introduction/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/linux/"><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0003-ali-cloud-server/">Ali云服务器配置</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>Gavin
        </a>发布于  <time datetime=0001-01-01>0001-01-01</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/server/">Server</a></span></div><div class="post-content"><a class="post-dummy-target" id="阿里云ecs服务器配置"></a><h2>阿里云ECS服务器配置</h2>
<p>趁着过年期间阿里云的新客活动，忍痛购买了3年的ECS云服务器，顺便可以给自己的域名挂上良民证，奥利给！</p>
<p>但是由于今年疫情的原因，备案时间会比较长，据说需要20天左右。而且之前一直只是在用Linux Client，于是趁着备案期间先熟悉一下阿里云Linux Server的使用和设置，下面是一些零零散散的~踩坑~学习记录。</p>
<a class="post-dummy-target" id="密码"></a><h3>密码</h3>
<p>管理密码是一件非常头疼的事情，每次设置完密码都会陷入沉思，&ldquo;woc&hellip;马什么梅来?&quot;。<br>
ECS实例创建后主要使用的有两个密码，分别是实例密码和远程连接密码。</p>
<ul>
<li>实例密码<br>
实例密码是Linux操作系统的密码，就是Root用户密码。奇怪的是创建实例时没有任何初始密码的提示，我是在创建完成后在服务控制台进行的密码重置，需要注意的是重置密码需要重启实例后才会生效。</li>
<li>远程连接密码<br>
远程连接密码是指阿里云控制台自带的远程连接工具的密码，这个密码最初是系统自动生成的6位数字，用户可以自定义修改这个远程连接密码。</li>
</ul>
<p>事实上，如果我们不使用阿里云控制台自带的VNC远程连接工具，那么就用不到远程连接密码。更改远程连接密码无需重启直接生效；实例密码是Linux系统下的root密码，Windows系统下的administrator密码，修改实例密码必须重启实例才可以生效。</p>
<a class="post-dummy-target" id="网络"></a><h2>网络</h2>
<p>阿里云面向客户提供的网络类型服务有经典网络和专有网络两种，官方文档给的解释是：</p>
<ul>
<li>经典网络<br>
ip地址由阿里云统一分配，配置简便，使用方便，适合对操作易用性要求比较高、需要快速使用 ECS 的用户。</li>
<li>专有网络<br>
是指逻辑隔离的私有网络，您可以自定义网络拓扑和 ip 地址，支持通过专线连接。适合于熟悉网络管理的用户。</li>
</ul>
<p>我们通俗点理解就是，经典网络和专有网络公网使用同一个公网ip。但是从内网ip来看，经典网络是DHIP，也就是系统自动分配局域网ip地址，而专有网络则是手动分配局域网ip地址，方便有多台云服务器的用户自行定义内网ip结构。所以，如果我们只有一台服务器，或者有多台服务器但不需要进行内网互联，那么这两种网络任选一个就可以了。</p>
<a class="post-dummy-target" id="带宽"></a><h2>带宽</h2>
<ul>
<li>入网带宽（上行带宽）<br>
流入云服务器ECS的带宽，例如：
<ul>
<li>云服务器ECS下载外部网络资源</li>
<li>FTP客户端上传资源到云服务器ECS</li>
</ul>
</li>
<li>出网带宽（下行带宽）<br>
流出云服务器ECS的带宽，例如：
<ul>
<li>云服务器ECS对外提供访问</li>
<li>FTP客户端下载云服务器ECS内部资源</li>
</ul>
</li>
</ul>
<a class="post-dummy-target" id="安全组"></a><h2>安全组</h2>
<p>安全组是ECS实例的虚拟防火墙，用于设置实例的网络访问控制，允许或拒绝公网请求和内网请求。<br>
安全组具备状态检测和数据包过滤功能，可以设置单台或多台云服务器的网络访问控制。<br>
每个实例必须属于至少一个安全组，一个安全组可以包括多个实例。同一安全组内的实例之间默认内网互通，不同安全组的实例之间默认内网不通，可以授权两个安全组之间互访。<br>
在创建实例时，系统会提供一个默认安全组，默认安全组中的默认规则仅设置针对ICMP协议、SSH 22端口、RDP 3389端口、HTTP 80端口和HTTPS 443端口的入方向规则。<br>
我们也可以自行创建一个安全组并添加能满足自己业务需求的安全组规则，自行创建的安全组在未添加任何安全组规则之前，出方向允许所有访问，入方向拒绝所有访问。</p>
<a class="post-dummy-target" id="添加安全组规则"></a><h3>添加安全组规则</h3>
<p>一般场景下我们需要设置的选项主要有两个：端口范围和授权对象，其他可参考默认设置。</p>
<ul>
<li>端口范围<br>
端口取值范围从1到65535，设置格式例如1/200或者80/80，其中“-1/-1”不能单独设置，代表不限制端口。</li>
<li>授权对象<br>
可以填写单个ip地址，例如223.78.253.196/32，填写0.0.0.0/0表示允许/拒绝全网段访问指定端口。<br>
可以填写多个ip地址，彼此之间用逗号隔开。<br>
此外还可以指定ip地址段，如 223.78.253.196/31，这将会授权/拒绝223.78.253.196和223.78.253.197的连接。</li>
</ul>
<a class="post-dummy-target" id="规则优先级"></a><h3>规则优先级</h3>
<p>同类型规则间依赖优先级（手动建立1-100，系统建立110）决定最终执行的规则。当ECS实例加入了多个安全组时，多个安全组会从高到低依次匹配规则。优先级取值范围如下所示，数值越小，优先级越高。</p>
<a class="post-dummy-target" id="实践建议"></a><h3>实践建议</h3>
<ul>
<li>仅允许少量请求访问ECS实例时，可以将安全组作为白名单使用。即先设置安全组为拒绝全部访问，然后逐一添加允许通信的访问请求策略。</li>
<li>选择开放具体的端口，如80/80端口，不要设置为端口范围。</li>
<li>添加安全组规则时，谨慎授权0.0.0.0/0（全网段）访问源。</li>
</ul>
<a class="post-dummy-target" id="案例"></a><h3>案例</h3>
<p>如果您在实例上架设了一个网站，希望您的用户能通过HTTPS服务访问到您的网站，您需要在实例所在安全组中添加以下安全组规则。</p>
<table>
<thead>
<tr>
<th align="center">网络类型</th>
<th align="center">网卡类型</th>
<th align="center">规则方向</th>
<th align="center">授权策略</th>
<th align="center">协议类型</th>
<th align="center">端口范围</th>
<th align="center">授权类型</th>
<th align="center">授权对象</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">VPC</td>
<td align="center">不需要配置</td>
<td align="center">入方向</td>
<td align="center">允许</td>
<td align="center">HTTPS</td>
<td align="center">443</td>
<td align="center">地址段访问</td>
<td align="center">0.0.0.0/0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">经典网络</td>
<td align="center">公网</td>
<td align="center">入方向</td>
<td align="center">允许</td>
<td align="center">HTTPS</td>
<td align="center">443</td>
<td align="center">地址段访问</td>
<td align="center">0.0.0.0/0</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="ssh连接实例"></a><h2>SSH连接实例</h2>
<p>Secure Shell（SSH）是一种加密网络协议，通过对传输内容进行加密在不安全的网络上安全地操作网络服务，常用于用户远程登录到计算机系统。<br>
SSH不是本文介绍的重点，详细请看这篇<a href="daibuchong">文章</a>，本文主要介绍阿里云SSH配置。</p>
<a class="post-dummy-target" id="root用户"></a><h3>Root用户</h3>
<p>首先，我们需要在安全组中开放入方向的22端口（默认已经开启），确认开启之后我们可以通过用户名密码验证和SSH密钥对验证两种方式远程连接服务器实例。密钥验证相对更加安全，而且阿里云的SSH密钥设置也非常简便，直接在控制台中即可完成。<br>
首先我们在 <code>云服务控制台 &gt; 网络与安全 &gt; 密钥对</code> 中创建密钥对并绑定实例，该密钥由ECS生成，默认采用RSA 2048位的加密方式。密钥绑定后，公钥会自动保存在实例中，我们把私钥保存到本地，然后便可通过Xshell等工具连接实例了。</p>
<a class="post-dummy-target" id="非root用户"></a><h3>非Root用户</h3>
<a class="post-dummy-target" id="实践注意事项"></a><h3>实践注意事项</h3>
<p>使用SSH密钥需要注意两点：</p>
<ul>
<li>如果使用SSH密钥对登录Linux实例，将会禁用密码登录，以提高安全性。<br>
如果在绑定密钥对之后想使用密码方式登录实例，可以通过重置实例密码实现。如果在绑定密钥对之后重置了实例密码，使用密钥对方式和使用密码方式均能登录实例。</li>
<li>基于数据安全考虑，在实例状态为运行中（Running）时绑定或者解绑密钥对，您需要重启实例使操作生效。</li>
</ul>
<a class="post-dummy-target" id="安全优化"></a><h3>安全优化</h3>
<a class="post-dummy-target" id="修改22端口"></a><h4>修改22端口</h4>
<p>Linux默认使用22端口进行远程登录，有一些人专门用服务器扫描22端口并使用弱口令等进行暴力破解，我们通过更改22端口可以过滤掉大部分暴力破解的访问。<br>
<ruby><rb>SSH服务</rb><rt>ssh daemon</rt></ruby>是OpenSSH软件套件中运行在服务器端的守护进程，作为服务器监听连接请求，它的配置文件是<code>/etc/ssh/sshd_config</code>。<br>
修改之前我们先备份配置文件，然后再进行编辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
vim /etc/ssh/sshd_config
</code></pre></td></tr></table>
</div>
</div><p>打开后可以看到如下内容：</p>
<pre>
	#	$OpenBSD: sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $

	# This is the sshd server system-wide configuration file.  See
	# sshd_config(5) for more information.

	# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

	# The strategy used for options in the default sshd_config shipped with
	# OpenSSH is to specify options with their default value where
	# possible, but leave them commented.  Uncommented options override the
	# default value.

	#Port 22
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
</pre>
<p>其中22端口被注释掉了。<br>
为了防止后续端口修改错误导致无法登录，我们先删除<code>#</code>保留<code>Port 22</code>端口，然后另起一行添加<code>Port 2222</code>，修改后的文件如下：</p>
<pre>
	Port 22
	Port 2222
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
</pre>
<p>修改完成后我们保存退出，重启sshd服务使配置生效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">systemctl restart sshd
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">service sshd restart
</code></pre></td></tr></table>
</div>
</div><p>重启完成后，我们可以通过<code>netstat -ntl</code>或<code>ss -ntl</code>命令查看一下端口。</p>
<p>配置完成后，记得在防火墙和安全组中放行<code>2222</code>端口，然后用新端口重新登录。<br>
如果登录成功，测试正常后，我们就可以注释或删除掉之前保留的<code>22</code>端口了。</p>
<p>需要注意的是，在<code>/etc/ssh/</code>目录下还有一个<code>ssh_config</code>文件，它是<code>ssh</code>的配置文件，记录了用户常用的选项和连接的主机。sshd(SSH服务器)运行在服务器端，监听incomming connection；ssh运行在客户端，用于客户端使用SSH协议连接其它机器。我们不要错误的修改了<code>ssh</code>的配置文件。</p>
<a class="post-dummy-target" id="ssh禁止root登录"></a><h4>SSH禁止root登录</h4>
<a class="post-dummy-target" id="ssh密钥登录"></a><h4>SSH密钥登录</h4>
<a class="post-dummy-target" id="ufw防火墙"></a><h4>UFW防火墙</h4>
<p><strong>特别提醒</strong><br>
<u>远程使用ufw需要注意开启远程连接的端口，或者设置定时关闭防火墙的脚本，防止自己连接不上</u><br>
<br />
UFW，即<ruby><rb>简单防火墙</rb><rt>uncomplicated firewall</rt></ruby>，是Ubuntu下的一个简易防火墙配置工具。<br>
UFW的使用非常简单，默认情况下UFW是没有开启的，我们使用以下命令就可以启动：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw <span class="nb">enable</span>
ufw default deny
</code></pre></td></tr></table>
</div>
</div><p>其中第一条命令是启动ufw，并将其设置为开机启动；第二条命令是使用ufw默认的规则，即关闭所有的外部对本机的访问，但本机访问外部正常。<br>
我们也可以关闭ufw防火墙及开机启动，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw disable
</code></pre></td></tr></table>
</div>
</div><p>我们可以使用allow命令打开指定的端口，举个例子，我们打开22和80端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw allow <span class="m">22</span>
ufw allow <span class="m">80</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以使用<code>delete allow</code>删除已经添加过的规则，举个例子，我们禁用80端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw delete allow <span class="m">80</span>
</code></pre></td></tr></table>
</div>
</div><p>规则设置完成后，我们可以重新加载来使规则生效（不重新加载也会生效），命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw reload
</code></pre></td></tr></table>
</div>
</div><p>现在可以通过以下命令查看防火墙的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw status
</code></pre></td></tr></table>
</div>
</div><ul>
<li><i class="far fa-check-square fa-fw"></i>禁止root用户登录</li>
<li><i class="far fa-check-square fa-fw"></i>禁止使用口令验证</li>
</ul></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0003-ali-cloud-server/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/server/"><i class="fas fa-tag fa-fw"></i>&nbsp;Server</a>
                    </span><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/ubuntu/"><i class="fas fa-tag fa-fw"></i>&nbsp;Ubuntu</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0002-hugo-concise-tutorial2/">Hugo简明教程2</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>Gavin
        </a>发布于  <time datetime=2020-02-04>2020-02-04</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/hugo/">Hugo</a></span></div><div class="post-content"><p>在上篇文章中，我们介绍了如何使用预创建的主题快速生成自己的静态网页并利用Github免费托管。</p>
<p>但是使用预创建的主题怎么能满足我们的需求，作为一个geek我们要的是随心所欲为所欲为！</p>
<p>接下来的教程就让我们从零开始，学习如何撸出一款高度定制化的Hugo主题吧！</p>
<a class="post-dummy-target" id="content-management"></a><h2>Content Management</h2>
<a class="post-dummy-target" id="basic-concepts"></a><h3>Basic Concepts</h3>
<ul>
<li>
<p>Content<br>
内容就是我们自己以markdown格式撰写的文章，通常我们把单独的文章放到content目录下，将同一类型的文章放到content的子目录下。<br>
文章可以通过命令行，如<code>hugo new about.md</code>生成，也可以手动创建后放入content目录下。</p>
</li>
<li>
<p>Template<br>
模板保存在两个地方，分别为<code>site/layouts</code>目录中和<code>site/themes/themename/layouts</code>目录中，其中前者的优先级高于后者，当前者为空时才去寻找后一个目录下的设置。<br>
模板主要分为以下几种，分别为基础模板（），单页模板（），列表模板（），局部模板（），首页模板以及404页面模板。</p>
</li>
<li>
<p>Static Page<br>
Static Page = Content + Template<br>
页面是通过<code>hugo</code>命令生成的静态网站中的html页面。Hugo会根据文章的kind属性和固定的规则去找到相应的模板，然后根据模板生成最终的html页面。<br>
最终我们自己创建的文章和Hugo自动创建的文件的路径会转换成对应的网站的url，文章、页面和url的对应关系为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">└── content
    ├── _index.md          // [home]            &lt;- https://example.com/**
    ├── about.md           // [page]            &lt;- https://example.com/about/
    ├── posts               
    |   ├── _index.md      // [section]         &lt;- https://example.com/posts/**         
    |   ├── firstpost.md   // [page]            &lt;- https://example.com/posts/firstpost/
    |   ├── happy           
    |   |   ├── _index.md  // [section]         &lt;- https://example.com/posts/happy/**
    |   |   └── ness.md    // [page]            &lt;- https://example.com/posts/happy/ness/
    |   └── secondpost.md  // [page]            &lt;- https://example.com/posts/secondpost/
    └── quote   
        ├── _index.md      // [section]         &lt;- https://example.com/quote/**           
        ├── first.md       // [page]            &lt;- https://example.com/quote/first/
        └── second.md      // [page]            &lt;- https://example.com/quote/second/
// hugo默认生成的页面, 没有对应的markdown文章
分类列表页面               // [taxonomyTerm]    &lt;- https://example.com/categories/**
某个分类下的所有文章的列表  // [taxonomy]        &lt;- https://example.com/categories/one-category **
标签列表页面               // [taxonomyTerm]    &lt;- https://example.com/tags/**
某个标签下的所有文章的列表  // [taxonomy]        &lt;- https://example.com/tags/one-tag **
</code></pre></td></tr></table>
</div>
</div><p><strong><em><small>注意：_index.md不是必须的, 如果没有找到_index.md，hugo会使用一些默认值。</small></em></strong><br>
页面总体分为两种，分别为<code>单页(signle page)</code>和<code>列表页(list page)</code>，根据<code>[]</code>中标注的页面<code>属性(kind)</code>，<code>single</code>包括<code>page</code>，<code>list</code>包括<code>home</code>, <code>section</code>, <code>taxonomyTerm</code>和<code>taxonomy</code>。其中，单页为用户撰写的文章，列表为Hugo自动创建的文件。</p>
</li>
</ul>
<p>LoveIt模板：<br>
_default/<br>
home page - baseof.html + summary.html<br>
posts - baseof.html + section.html<br>
post - baseof.html + patrial/<br>
about - baseof.html + single.html</p>
<p>posts/<br>
single.html</p>
<p>在编写模板的时候，一般会先编写一个基础模板。然后将一些常用的公用模板，如导航栏、页首、页脚等，做成单独的子模板，在需要的时候将这些子模板导入基础模板。<br>
Hugo默认的基础模板页是<code>_default/baseof.html</code>。</p></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0002-hugo-concise-tutorial2/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/hugo/"><i class="fas fa-tag fa-fw"></i>&nbsp;Hugo</a>
                    </span><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/tutorial/"><i class="fas fa-tag fa-fw"></i>&nbsp;Tutorial</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="http://belldrum.com/2020/02/0001-hugo-concise-tutorial/">Hugo简明教程1</a>
    </h1><div class="post-meta"><a class="author" href="http://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>GUO Chen
        </a>发布于  <time datetime=2020-02-03>2020-02-03</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="http://belldrum.com/categories/hugo/">Hugo</a></span></div><div class="post-content"><p>Hugo是由GO语言实现的静态网站生成器，自称“The world&rsquo;s fastest framework for building websites”。</p>
<p>静态网站的好处是快速、安全和易于部署，最主要的是可以利用版本控制系统来进行管理。<br>
本文介绍了如何使用Hugo快速搭建个人网站以及如何利用免费的github pages进行发布。</p>
<a class="post-dummy-target" id="step-1-install-hugo-for-win"></a><h2>Step 1: Install Hugo for Win</h2>
<p>在release<a href="https://github.com/gohugoio/hugo/releases" target="_blank"><u>下载</u></a> 对应版本的二进制文件，二进制版本的好处是无需安装额外依赖。下载完成后解压获得hugo.exe文件，然后将其所在路径添加到环境变量PATH中，方便在命令行中使用。</p>
<p>添加成功后，在cmd中输入<code>hugo version</code>检查是否安装成功，如果安装成功会输出<br>
<code>Hugo Static Site Generator v0.63.2-934EE21F windows/amd64 BuildDate: 2020-01-27T12:14:15Z</code>。</p>
<p>我们也可以通过执行<code>hugo -help</code>查看命令帮助。</p>
<a class="post-dummy-target" id="step-2-create-a-new-site"></a><h2>Step 2: Create a New Site</h2>
<p>创建一个新的hugo站点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo new site path/to/site
</code></pre></td></tr></table>
</div>
</div><p>该命令会在site目录下创建一个新的hugo站点，文件目录结构如下：<br>
site/ <br>
├─ archetypes<br>
│  └─ default.md<br>
├─ config.toml <br>
├─ content<br>
├─ data<br>
├─ layouts<br>
├─ static<br>
└─ themes</p>
<ul>
<li>config.toml<br>
站点的全局参数配置文件</li>
<li>archetypes<br>
存放default.md文件，该文件定义了Hugo的markdown文件<code>前置数据(Front Matter)</code>的结构，可以理解为markdown的metadata。我们可以自定义该结构文件，然后在config.toml中指定自定义的结构文件。Front Matter支持三种格式，分别为yaml，toml和json。默认生成的default.md文件为yaml格式，至少包括以下3项：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-YAML" data-lang="YAML"><span class="w">	</span>--- <span class="w"> 
</span><span class="w">	</span><span class="k">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;{{ replace .Name &#34;</span>-<span class="s2">&#34; &#34;</span><span class="w"> </span><span class="s2">&#34; | title }}&#34;</span><span class="w">  
</span><span class="w">	</span><span class="k">date</span><span class="p">:</span><span class="w"> </span>{{<span class="w"> </span>.Date<span class="w"> </span>}}<span class="w">  
</span><span class="w">	</span><span class="k">draft</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  
</span><span class="w">	</span>--- <span class="w"> 
</span></code></pre></td></tr></table>
</div>
</div><p>  <code>draft</code>为<code>true</code>表示该文章处于草稿状态，不会被渲染和显示，发布时需要改为<code>false</code>。</p>
<ul>
<li>
<p>content<br>
存放网页内容的目录，我们编写的markdown文件都存放在该目录中，是Hugo的默认源目录。</p>
</li>
<li>
<p>data<br>
data目录用来存放数据文件，一般是json文件，Hugo提供了相关命令可以从data目录下读取相关的文件数据，然后渲染到HTML页面中，将业务数据与模板分离。</p>
</li>
<li>
<p>layouts<br>
存放自定义的模板文件，Hugo优先使用layouts目录下的模板，未发现再去themes目录下查找。模板是以<code>.html</code>文件指明如何将内容视图渲染为静态页面。<br>
模板包括列表页面、主页、分类模板、partals、单页模板等。</p>
</li>
<li>
<p>static<br>
存放所有的静态内容，如images, css、js、CNAME等。Hugo在渲染时，会将static目录下的文件直接复制到public目录下，不会做任何渲染。</p>
</li>
<li>
<p>themes<br>
存放网站主题，可以下载多个主题，themes目录下的每个子目录代表了一个主题。可以通过在config.toml中通过参数theme指定主题，即theme目录下的子目录名字，也可以在执行hugo命令渲染时通过增加flag参数–theme=xx指定。</p>
</li>
</ul>
<a class="post-dummy-target" id="step-3-add-a-theme"></a><h2>Step 3: Add a Theme</h2>
<p>Hugo允许我们创建自己的主题或者使用预创建的开源主题。使用预创建的主题可以为我们节约大量的时间，避免关注不必要的技术细节而专注于内容的输出。让我们使用预创建的主题快速开始吧！</p>
<p>首先我们挑选一个喜欢的 <a href="https://themes.gohugo.io/" target="_blank"><u>hugo主题</u></a> ，例如 <a href="https://themes.gohugo.io/loveit/" target="_blank"><u>LoveIt</u></a>，然后将主题下载到themes目录下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> path/to/site
git init
git clone https://github.com/xx/xx.git themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><p>执行成功后，会在themesm目录下生成主题目录LoveIt。<br>
添加主题到配置文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s1">&#39;theme = &#34;LoveIt&#34;&#39;</span> &gt;&gt; config.toml
</code></pre></td></tr></table>
</div>
</div><p>或直接用文本编辑器打开config.toml修改相应的配置。</p>
<p>一个快速简便的配置方法是用<code>themes/loveit/exampleSite</code>下的<code>config.toml</code>替换<code>/site</code>站点目录下默认生成的<code>config.tmol</code>。</p>
<a class="post-dummy-target" id="step-4-add-some-content"></a><h2>Step 4: Add Some Content</h2>
<p>我们可以手动创建内容文件（content files），然后添加metadata，如title和data等。也可以通过下面的命令自动创建草稿：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo new posts/my-first-post.md
</code></pre></td></tr></table>
</div>
</div><p>在<code>content/posts</code>目录中会生成一篇名为<code>my-first-post.md</code>的文章草稿，并自动添加<code>archetypes/default.md</code>中的内容。</p>
<a class="post-dummy-target" id="step-5-hosting-hugo-site-locally"></a><h2>Step 5: Hosting Hugo Site Locally</h2>
<p>在站点目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo server
</code></pre></td></tr></table>
</div>
</div><p>启动服务器后，可以通过<a href="http://localhost:1313/" target="_blank">http://localhost:1313/</a>访问站点并调试。Hugo支持所谓的LiveReload，相应配置及内容的修改会即刻生效并在浏览器中加载。</p>
<a class="post-dummy-target" id="step-6-build-static-pages"></a><h2>Step 6: Build Static Pages</h2>
<p>在创建静态页面之前，我们需要对<code>config.toml</code>进行配置。因为我们准备将该网页托管到github pages上，需要将baseURL修改为&quot;https://yourgithubusername.github.io/&quot;。<br>
调试无误后，我们在站点目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo
</code></pre></td></tr></table>
</div>
</div><p>该命令会在站点目录下新建一个public子目录，然后将渲染后的全部站点文件输出到该目录中。<br>
我们可以将public目录中的文件直接提交到github上以Githbu Pages方式发布，也可以部署到自己的服务器上。</p>
<a class="post-dummy-target" id="step-7-hosting-on-github-pages"></a><h2>Step 7: Hosting on Github Pages</h2>
<p>我们在github中新建一个repo，命名为<code>yourgithubusername.github.io</code>，然后将public中的文件push到该仓库中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> path/to/site/public
git init
git remote add origin https://github.com/yourgithubusername/yourgithubusername.github.io
git add.
git commit -m <span class="s2">&#34;your message&#34;</span>
git push origin master
</code></pre></td></tr></table>
</div>
</div><p>叮！ 通过<u><a href="http://yourgitubusername.github.io">http://yourgitubusername.github.io</a></u> 访问你的网站吧。</p>
<a class="post-dummy-target" id="reference"></a><h2>Reference</h2>
<ol>
<li><a href="https://s0gohugo0io.icopy.site/documentation/" target="_blank">Hugo Documentation</a></li>
</ol></div><div class="post-footer">
        <a href="http://belldrum.com/2020/02/0001-hugo-concise-tutorial/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/hugo/"><i class="fas fa-tag fa-fw"></i>&nbsp;Hugo</a>
                    </span><span class="tag">
                        &nbsp;<a href="http://belldrum.com/tags/tutorial/"><i class="fas fa-tag fa-fw"></i>&nbsp;Tutorial</a>
                    </span></div></div>
</article></div></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="http://belldrum.com/" target="_blank">Gavin</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                <span class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank">鲁ICP备20005030-1</a></span><span class="copyright-line">
				&nbsp;|&nbsp;Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> & <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt</a>
			</span>
		</div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><script src="/js/lib/typeit/typeit.min.js"></script><script>window.typeitArr=[["tp-1bf8abddf514ac940e9ba88fb259fd6a"]];</script><link rel="stylesheet" href="/css/lib/katex/katex.min.css"><script src="/js/lib/katex/katex.min.js"></script><script defer src="/js/lib/katex/auto-render.min.js"></script><link rel="stylesheet" href="/css/lib/katex/copy-tex.min.css"><script defer src="/js/lib/katex/copy-tex.min.js"></script><script defer src="/js/lib/katex/mhchem.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true },{ left: "$", right: "$", display: false },]
            });
        });
    </script><script src="/js/blog.min.js"></script></body>
</html>