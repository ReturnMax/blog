<!DOCTYPE html>
<html lang="zh">
    <head>
	<meta name="generator" content="Hugo 0.63.2" />
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>晨钟暮鼓</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="Gavin&#39;s Blog"><link rel="canonical" href="https://belldrum.com/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><link rel="alternate" href="/index.xml" type="application/rss+xml" title="晨钟暮鼓">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="晨钟暮鼓"><meta property="og:title" content="晨钟暮鼓" />
<meta property="og:description" content="Gavin&#39;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://belldrum.com/" />
<meta property="og:updated_time" content="2020-02-28T00:25:28+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="晨钟暮鼓"/>
<meta name="twitter:description" content="Gavin&#39;s Blog"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/belldrum.com\/","author": {
                "@type": "Person",
                "name": "嘉文"
            },"description": "Gavin\x27s Blog","image": "https:\/\/belldrum.com\/cover.png","thumbnailUrl": "https:\/\/belldrum.com\/logo.png","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","name": "晨钟暮鼓"
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/css/lib/animate/animate.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://belldrum.com/">晨钟暮鼓</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://belldrum.com/posts" title="">文章</a><a class="menu-item" href="https://belldrum.com/tags" title="">标签</a><a class="menu-item" href="https://belldrum.com/categories" title="">分类</a><a class="menu-item" href="https://belldrum.com/about" title="">关于</a><a class="menu-item" href="https://belldrum.com/" title="主页"><i class="fas fa-home fa-fw"></i></a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://belldrum.com/">晨钟暮鼓</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://belldrum.com/posts" title="">文章</a><a class="menu-item" href="https://belldrum.com/tags" title="">标签</a><a class="menu-item" href="https://belldrum.com/categories" title="">分类</a><a class="menu-item" href="https://belldrum.com/about" title="">关于</a><a class="menu-item" href="https://belldrum.com/" title="主页"></a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="切换主题"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><div class="page"><div class="home-intro"><div class="home-avatar">
            <a href="/posts">
                <img src=/images/avatar.png alt="avatar" title="主页">
            </a>
        </div><h2 class="home-description"><div id=rtp-1bf8abddf514ac940e9ba88fb259fd6a hidden=true>悟已往之不谏，知来者之可追</div>
            <div id=tp-1bf8abddf514ac940e9ba88fb259fd6a class="typeit"></div></h2><div class="home-social-links"><a href="https://github.com/xxxx" rel="me noopener noreffer" target="_blank">
        <i class="fab fa-github-alt fa-fw" title="Github"></i>
    </a><a href="https://linkedin.com/in/xxxx" rel="me noopener noreffer" target="_blank">
        <i class="fab fa-linkedin fa-fw" title="LinkedIn"></i>
    </a>
    <a href="mailto:chnguo@outlook.com" rel="me noopener noreffer">
        <i class="far fa-envelope fa-fw" target="_blank" title="Email"></i>
    </a></div>
</div>
<article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2020/02/0009-ssh-intro2/">SSH 原理与实践</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=2020-02-28>2020-02-28</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="https://belldrum.com/categories/server/">Server</a></span></div><div class="post-content"><p>OpenSSH是SSH协议的一个免费开源实现，是用于使用SSH协议进行远程登录的主要连接工具。它对所有流量进行加密，以消除窃听、连接劫持等攻击。此外，OpenSSH还提供了一整套安全的隧道功能、多种身份验证方法以及复杂的配置选项。</p>
<p>OpenSSH软件主要包含以下几种工具：</p>
<ul>
<li>服务器端由SSH服务(sshd)、sftp-server和ssh-agent组成</li>
<li>客户端使用ssh-keygen、ssh-add、ssh-kyesign、ssh-keyscan等管理密钥</li>
<li>远程操作使用ssh、scp和sftp完成</li>
</ul>
<p>本文主要介绍SSH的工作流程以及OpenSSH部分工具的使用。</p>
<a class="post-dummy-target" id="认证过程"></a><h2>认证过程</h2>
<p>SSH 协议使用对称加密(symmetric encryption)，非对称加密(asymmetric encryption)和哈希(hashing)来保证信息传输的安全。客户端和服务器端的SSH连接过程主要包括三个阶段：</p>
<ol>
<li>在客户端进行服务器验证</li>
<li>生成会话密钥(session key)加密所有通信</li>
<li>客户认证</li>
</ol>
<a class="post-dummy-target" id="服务器验证"></a><h3>服务器验证</h3>
<p>Ssh连接采用客户端-服务器模型(c/s)，客户端首先向服务器发送连接请求，服务器端运行的SSH服务(sshd)默认监听22端口并处理连接请求，这时客户端需要验证服务器的身份。服务器身份验证主要有两种情况：</p>
<p><strong>1. 首次连接</strong><br>
如果客户端是第一次连接服务器，则要求客户端通过验证服务器的公钥来手动认证服务器。服务器的公钥一般保存在<code>/etc/ssh/host_key*</code>，也可以使用ssh-keyscan命令找到。一旦服务器密钥被接受，那么将会被添加到客户端<code>~/.ssh/know_hosts</code>文件中。<code> known_hosts</code>文件包含有关客户端所有已验证服务器的信息。<br>
<strong>2. 再次连接</strong><br>
如果客户端不是第一次访问要连接的服务器，则将服务器的身份与<code>known_hosts</code>文件中先前记录的信息进行匹配以进行验证。<br>
<br />
服务器的身份需要用户手动进行验证，这样做的目的主要是为了防止中间人攻击(Man-in-the-middle attack, MITM)。</p>
<a class="post-dummy-target" id="生成会话密钥"></a><h3>生成会话密钥</h3>
<p>验证服务器后，服务器端和客户端使用<code>Diffie-Hellman</code>算法生成会话密钥(session key)。 该算法的设计方式是，双方在会话密钥的生成中会做出同等贡献。 生成的会话密钥是在客户端和服务器端共享的对称密钥，即双方使用相同的密钥加密和解密。</p>
<a class="post-dummy-target" id="客户端认证"></a><h3>客户端认证</h3>
<p>最后阶段是使用SSH密钥对来验证客户端的身份。顾名思义，SSH密钥对由两个不同目的的密钥组成： 公钥用于加密数据并可以自由分发，私钥用于解密数据，并且永远不会与任何人共享。  对称加密建立后，将对客户端进行身份验证，验证过程如下：</p>
<ol>
<li>客户端首先向服务器发送要验证的密钥对的ID。</li>
<li>服务器检查客户端尝试登录的帐户的authorized_keys文件中的密钥ID。</li>
<li>如果在文件中找到匹配该ID的公钥，那么服务器将生成一个随机数，然后使用客户端公钥对随机数进行加密并将加密的消息发送给客户端。</li>
<li>如果客户端拥有正确的私钥，它将解密该消息以获得服务器生成的随机数。</li>
<li>客户端将获得的随机数与共享的会话密钥结合在一起，并计算该值的MD5哈希值。</li>
<li>然后，客户端将此MD5哈希发送回服务器，作为对加密号码消息的答复。</li>
<li>服务器使用相同的共享会话密钥和发送给客户端的原始号码自行计算MD5值。它将自己的计算结果与客户端发回的计算结果进行比较。如果这两个值匹配，则证明该客户端拥有私钥，并且该客户端已通过身份验证。</li>
</ol>
<p>不对称密钥允许服务器对客户端进行身份验证，因为客户端只有在拥有正确的关联私钥的情况下才能解密消息。<br>
此外，SSH支持多种身份验证机制，最常见的是<strong>密码认证</strong>和<strong>公钥认证</strong>。上文只说明了公钥认证过程，当公钥认证未通过时，会再进行密码认证，此处不再赘述。</p>
<a class="post-dummy-target" id="对称加密"></a><h2>对称加密</h2>
<p>我们在前文中介绍过，SSH 协议使用对称加密(symmetric encryption)，非对称加密(asymmetric encryption)和哈希(hashing)来保证信息传输的安全。<br>
大部分教程对非对称密钥的作用有详细的介绍，但在对称密钥介绍时往往语焉不详，造成很多人的误解。本节主要是希望大家了解一点，<strong>SSH使用对称密钥来加密整个连接，非对称密钥仅用于身份验证</strong>。</p>
<p>对称加密是一种加密类型，使用同一个密钥加密发给对方的消息、解密从另一方收到的消息。这意味着拥有密钥的任何人都可以加密和解密发送给拥有密钥的其他人的消息。这种加密模式通常称为“shared secret”加密或“secret key”加密。通常，只有一个密钥用于所有操作，或者只有一对密钥，它们之间的关系很容易发现，或者很容易根据一个密钥推导出另一个密钥。</p>
<p>SSH使用对称密钥来加密整个连接。与一些人的假设相反，我们创建的公有/私有非对称密钥对仅用于身份验证，而不用于加密连接。对称加密甚至可以保护密码验证免遭监听。</p>
<p>客户端和服务端为生成对称密钥做出了同等的贡献，并且最终生成的密钥永远不会为外界所知。这个密钥是通过密钥交换算法创建的，这种算法允许服务器和客户端共享某些公共数据，然后使用各自保留的秘密数据进行处理，最终两者独立地到达相同的目的：生成同一密钥。更详细地说明可参考这篇<a href="https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process" target="_blank">文章</a>。</p>
<p>通过此过程创建的对称加密密钥是基于会话的(session-bassed)，并且构成了服务器与客户端之间发送的数据的实际加密。一旦建立，必须使用此共享密钥对其余数据进行加密。这个阶段完成之后，服务端和客户端的加密会话就被建立了，然后开始进行客户端的验证。</p>
<p>SSH可以使用多种对称密码系统，包括AES，Blowfish，3DES，CAST128和Arcfour等。服务器和客户端都可以决定其支持的密码列表，按优先顺序排序。最终两者进行协商，客户端列表中的第一个在服务器上可用的选项将被用作两个方向上的加密算法。</p>
<a class="post-dummy-target" id="文件介绍"></a><h2>文件介绍</h2>
<p>SSH密钥验证过程涉及客户端和服务器端的多个文件，为了避免混淆，我们来总结一下各个文件的作用。</p>
<p><strong>服务端：</strong></p>
<ul>
<li><code>/etc/ssh/sshd_config</code><br>
ssh服务程序(sshd)的配置文件<br>
<br /></li>
<li><code>etc/ssh/ssh_host_*</code><br>
ssh服务程序(sshd)启动时自动生成的服务端公钥和私钥文件，也可以通过<code>dpkg-reconfigure openssh-server</code>命令重新生成。共有八个文件，包括四种加密类型：<code>rsa</code>、<code>dsa</code>、<code>ecdsa</code>和<code>ed25519</code>（实际使用时服务器会选择其中一种加密类型）。其中<code>.pub</code>结尾的是公钥，将写入到客户端的<code>~/.ssh/known_hosts</code>文件中，用于验证服务器身份。<br>
其中私钥文件严格要求权限为600，若不是则sshd服务可能会拒绝启动。<br>
<br /></li>
<li><code>~/.ssh/authorized_keys</code><br>
保存的是基于公钥认证机制时客户端用户的公钥。在进行客户端认证时，服务端将读取对应用户目录下的<code>authorized_keys</code>文件。<br>
<br /></li>
</ul>
<p><strong>客户端：</strong></p>
<ul>
<li><code>/etc/ssh/ssh_config</code><br>
客户端的全局配置文件。<br>
<br /></li>
<li><code>~/.ssh/config</code><br>
客户端的用户配置文件，生效优先级高于全局配置文件。一般该文件默认不存在，可自行创建。该文件对权限有严格要求，只对所有者有读/写权限，对其他人完全拒绝写权限。<br>
<br /></li>
<li><code>~/.ssh/known_hosts</code><br>
保存服务器验证时服务端<code>host key</code>的文件，文件内容来源于服务端的<code>ssh_host_*_key.pub</code>文件。<br>
<br /></li>
<li><code>/etc/ssh/known_hosts</code><br>
全局<code>host key</code>保存文件，作用等同于<code>~/.ssh/known_hosts</code>。<br>
<br /></li>
<li><code>~/.ssh/id_rsa</code><br>
客户端生成的私钥。由ssh-keygen生成。该文件严格要求权限，文件权限不得大于<code>711</code>，一般设置为<code>600</code>。<br>
<br /></li>
<li><code>~/.ssh/id_rsa.pub</code><br>
私钥<code>id_rsa</code>的配对公钥。对权限不敏感。当采用公钥认证机制时，该文件内容需要提前复制到服务端的<code>~/.ssh/authorized_keys</code>文件中。<br>
<br /></li>
<li><code>~/.ssh/rc</code><br>
保存的是命令列表，这些命令在ssh连接到远程主机成功时将第一时间执行，执行完这些命令之后才开始登陆或执行ssh命令行中的命令。<br>
<br /></li>
<li><code>/etc/ssh/rc</code><br>
作用等同于<code>~/.ssh/rc</code></li>
</ul>
<p><strong>注意：</strong><br>
配置文件主要包括服务端配置文件<code>/etc/ssh/sshd_config</code>和客户端配置文件<code>/etc/ssh/ssh_config</code>。这两个文件中有很多同名的配置项，但前者是sshd启动时开关性的设置，后者是请求连接时客户端采取的配置。例如，两配置文件都有GSSAPIAuthentication项，在客户端将其设置为no，表示连接时将直接跳过该身份验证机制，而在服务端设置为no则表示sshd启动时不开启GSSAPI身份验证的机制。即使客户端使用了GSSAPI认证机制，只要服务端没有开启，就绝对不可能认证通过。</p>
<a class="post-dummy-target" id="认证实现"></a><h2>认证实现</h2>
<p>前文介绍了公钥认证的过程以及涉及到的文件，接下来主要介绍公钥认证的具体实现步骤。<br>
公钥认证过程主要包括两个步骤：1)生成密钥对和 2)分发公钥。</p>
<a class="post-dummy-target" id="生成密钥对"></a><h3>生成密钥对</h3>
<p>OpenSSH提供了密钥生成工具ssh-keygen。我们在客户端（服务端也行，无所谓在哪生成）执行<code>ssh-keygen</code>指令会出现如下提示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ssh-keygen -t rsa 	<span class="c1">#-t参数指定算法，通常使用rsa或dsa</span>
Generating public/private rsa key pair.
Enter file in which to save the key <span class="o">(</span>/root/.ssh/id_rsa<span class="o">)</span>:  <span class="c1"># 输入密钥对保存路径，与-f参数作用相同</span>
Enter passphrase <span class="o">(</span>empty <span class="k">for</span> no passphrase<span class="o">)</span>:               <span class="c1"># 输入私钥密码，可留空，与-P参数作用相同</span>
Enter same passphrase again:            
Your identification has been saved in /root/.ssh/id_rsa. 
Your public key has been saved in /root/.ssh/id_rsa.pub. 
</code></pre></td></tr></table>
</div>
</div><p>如不指定保存路径，那么生成的密钥对默认保存在<code>~/.ssh/</code>目录下。其中，私钥的权限设置为<code>600</code>，如果权限过大会导致公钥认证失败。</p>
<a class="post-dummy-target" id="分发公钥"></a><h3>分发公钥</h3>
<p>密钥生成后，我们要将公钥发送到远程服务器对应用户的家目录下，可以使用<code>ssh-copy-id</code>命令实现，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ssh-copy-id <span class="o">[</span>-i <span class="o">[</span>identity_file<span class="o">]</span><span class="o">]</span> <span class="o">[</span>user@<span class="o">]</span>host
</code></pre></td></tr></table>
</div>
</div><ul>
<li>-i 指定要分发的公钥文件</li>
<li>user 指定对应的用户名</li>
</ul>
<p>举个例子，我们将公钥分发到服务器<code>114.55.93.224</code>上的<code>gavin</code>用户家目录下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ssh-copy-id -i .ssh/id_rsa.pub gavin@114.55.93.224
</code></pre></td></tr></table>
</div>
</div><p>而如果ssh服务端的端口不是22，还需要给<code>ssh-copy-id</code>传递端口号，格式为<code>&quot;-p port_num [user@]hostname&quot;</code>，如 <code>&quot;-p 2222 gavin@114.55.93.224&quot;</code>。</p>
<p><code>ssh-copy-id</code>命令的作用是在目标主机的指定用户的家目录下，检测是否有<code>~/.ssh</code>目录，如果没有，则以700权限创建该目录，然后将本地的公钥追加到目标主机指定用户家目录下的<code>~/.ssh/authorized_keys</code>文件中。<code>authorized_keys</code>文件可以保存多个公钥信息，每个公钥以换行分开。<br>
<br />
因此，我们也可以直接将公钥文件传输到服务器上，然后手动将公钥追加到对应用户家目录下的<code>.ssh/authorized_keys</code>文件中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">cat id_rsa &gt;&gt; authorized_keys
</code></pre></td></tr></table>
</div>
</div><p>公钥分发完成后，我们就可以远程连接服务器了。</p>
<a class="post-dummy-target" id="最佳实践"></a><h2>最佳实践</h2>
<a class="post-dummy-target" id="更改默认端口"></a><h3>更改默认端口</h3>
<p>Linux默认使用22端口进行远程登录，一些人专门用服务器扫描22端口并使用弱口令等进行暴力破解，通过更改22端口可以过滤掉大部分暴力破解的访问。<br>
<ruby><rb>SSH服务</rb><rt>ssh daemon</rt></ruby>是OpenSSH软件套件中运行在服务器端的守护进程，它的配置文件是<code>/etc/ssh/sshd_config</code>，在配置文件中可以修改守护进程监听的端口。</p>
<p>在修改之前我们先对配置文件进行备份，然后用文本编辑工具打开：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
vim /etc/ssh/sshd_config
</code></pre></td></tr></table>
</div>
</div><p>打开后可以看到如下内容：</p>
<pre>
	#	$OpenBSD: sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $

	# This is the sshd server system-wide configuration file.  See
	# sshd_config(5) for more information.

	# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

	# The strategy used for options in the default sshd_config shipped with
	# OpenSSH is to specify options with their default value where
	# possible, but leave them commented.  Uncommented options override the
	# default value.

	#Port 22
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
</pre>
<p>其中22端口被注释掉了。<br>
为了防止后续端口修改错误导致无法登录，我们先删除<code>#</code>保留<code>Port 22</code>端口，然后另起一行添加<code>Port 2222</code>，修改后的文件如下：</p>
<pre>
	Port 22
	Port 2222
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
</pre>
<p>修改完成后我们保存退出，重启sshd服务使配置生效：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">systemctl restart sshd
</code></pre></td></tr></table>
</div>
</div><p>或</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">service sshd restart
</code></pre></td></tr></table>
</div>
</div><p>重启完成后，我们可以通过<code>netstat -ntl</code>或<code>ss -ntl</code>命令查看一下端口。</p>
<p>配置完成后，记得在防火墙和安全组中放行<code>2222</code>端口，然后用新端口重新登录。<br>
如果登录成功，测试正常后，我们就可以注释或删除掉之前保留的<code>22</code>端口了。</p>
<a class="post-dummy-target" id="禁止root登录"></a><h3>禁止root登录</h3>
<p>修改<code>/etc/ssh/sshd_config</code>文件：</p>
<pre>
PermitRootLogin yes			# 是否允许root用户登录，默认为yes
</pre>
<a class="post-dummy-target" id="禁止口令登录"></a><h3>禁止口令登录</h3>
<p>修改<code>/etc/ssh/sshd_config</code>文件：</p>
<pre>
PasswordAuthentication yes		# 是否使用密码验证，默认为yes，如果使用密钥对验证可以关闭
</pre>
<a class="post-dummy-target" id="待补充"></a><h3>待补充</h3>
<a class="post-dummy-target" id="参考资料"></a><h2>参考资料</h2>
<ol>
<li><a href="https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process" target="_blank">Understanding the SSH Encryption and Connection Process</a></li>
<li><a href="https://medium.com/@Magical_Mudit/understanding-ssh-workflow-66a0e8d4bf65" target="_blank">Understanding SSH workflow</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/7129122.html" target="_blank">SSH命令和SSH服务详解</a></li>
</ol></div><div class="post-footer">
        <a href="https://belldrum.com/2020/02/0009-ssh-intro2/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/ssh/"><i class="fas fa-tag fa-fw"></i>&nbsp;SSH</a>
                    </span><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/server/"><i class="fas fa-tag fa-fw"></i>&nbsp;Server</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2020/02/0007-nginx/">Nginx 配置介绍</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=2020-02-21>2020-02-21</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="https://belldrum.com/categories/server/">Server</a></span></div><div class="post-content"><p>Nginx是一款轻量级的Web服务器，也可作为反向代理服务器、邮件服务器等。</p>
<p>说到服务器 (Server) 通常会想到两种概念：1) 硬件，就是一台机器，有时也称之为「主机」和 2) 软件，主要用来对外提供一些服务，如邮件服务、数据库服务、网页服务等，它们24小时不间断的运行并监听某些固定的端口，等待客户端的连接并作出回应。</p>
<p>本文主要介绍如何使用Nginx作为Web服务器快速部署静态网站，对许多配置选项并没有做出详细说明，更加详细的说明请参见文末 <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">参考资料</a>。</p>
<a class="post-dummy-target" id="软件安装"></a><h2>软件安装</h2>
<p>在Debian下可以使用<code>apt-get</code>安装nginx：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">apt-get install nginx
</code></pre></td></tr></table>
</div>
</div><p>默认安装位置在<code>/etc/nginx</code>。在Ubuntu 18.04系统中，nginx安装完成后会自动启动。如果没有启动，我们可以执行<code>nginx</code>命令手动启动。<br>
<br />
我们通过<code>ps -aux</code>命令可以看到nginx的master进程和worker进程，分别由root用户和www-data用户启动。<br>
Master进程主要负责读取并验证配置文件nginx.conf，管理worker进程；Worker进程负责处理连接和请求；Worker进程的个数由配置文件决定，一般和CPU核心个数相同（有利于进程切换）。</p>
<p>安装完成后，在浏览器输入服务器的公网IP，正常情况下可以看到nginx的默认欢迎页（确认已放行80端口）。</p>
<p>接下来修改nginx的配置文件，使这个地址指向我们的网站首页而不是ngixn的默认网页。</p>
<a class="post-dummy-target" id="配置文件"></a><h2>配置文件</h2>
<p>默认情况下，nginx的配置文件是<code>/etc/nginx/nginx.conf</code>。Nginx 配置信息主要分为六大部分： main(全局设置)、events(事件设置)、http(HTTP服务器设置)、 sever(虚拟主机设置)、location(URL匹配设置)、upstream(反向代理设置)。</p>
<p>配置文件里大部分内容是注释掉的，文件内容如下：</p>
<pre>
user www-data www-data;				//配置用户和用户组，用户组可以为空
worker_processes auto;				//允许生成的进程数，通常设置成和cpu核心数量相等
pid /run/nginx.pid;				//指定nginx进程运行文件存放位置
include /etc/nginx/modules-enabled/*.conf;
//引用modules-enabled目录下.conf配置文件

events {					//events块，配置影响nginx服务器或与用户的网络连接
	worker_connections 768;			//设置最大连接数
	# multi_accept on;			//设置一个进程是否同时接受多个网络连接
}

http {						//http块，可以嵌套多个server
	sendfile on;				//开启高效文件传输模式，去掉将数据复制到缓冲区的步骤
	keepalive_timeout 65;			//长连接超时时间，默认单位是秒
	...
	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
	...
	gzip on;				//开启gzip压缩输出，减少网络传输
	...
	server {				//server块，配置虚拟主机的参数
		listen 80;			//server监听端口
		server_name belldrum.com	//虚拟服务名，可设为主机公网IP地址或域名
		location {			//配置请求的路由和页面的处理
		}
	}
}
</pre>
<a class="post-dummy-target" id="部署网站"></a><h2>部署网站</h2>
<p>假设我们的网站根目录为<code>/home/gavin/blog</code>。<br>
我们在http上下文 (http context) 中定义一个虚拟服务器 (Virtual Server)，并添加以下内容：</p>
<pre>
http {
	server {
		listen 80;			//监听端口
		server_name belldrum.com;	// 虚拟服务器名
		root /home/gavin/blog;		// 网站资源根目录，nginx需要有该目录的读取权限
		index index.html;		// 显示首页
		location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt){
    			root /home/gavin/blog;
		}				// 配置路由
	}
}
</pre>
<p>其中，<code>listen</code>指令中如果省略端口，那么默认会使用标准端口；如果省略IP地址将监听所有地址，上面的例子中已省略地址。<br>
如果有多个虚拟服务器与请求的IP地址和端口相匹配，那么将对照<code>server_name</code>指令测试请求的Host头字段。</p>
<p>修改完成后保存退出，执行<code>nginx -s reload</code>重启nginx服务，便可以通过域名或IP地址访问自己的网站了。<br>
<br />
我们也可以不用修改<code>nginx.conf</code>文件，而是通过在该文件中使用<code>include</code>指令管理额外的配置文件。上面的例子中已经通过<code>include</code>指令引入了<code>conf.d</code>、<code>sites-enable</code>、<code>modules-enabled</code>三个目录下的配置文件。我们可以直接在这些目录下新建一个虚拟主机的配置文件，或者在任意目录下新建，然后在<code>nginx.conf</code>的http上下文中用<code>include</code>引用。<br>
<br />
举个例子：<br>
我们在conf.d目录下新建一个名为<code>belldrum.com.conf</code>的配置文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> /etc/nginx/conf.d
vim belldrum.com.conf
</code></pre></td></tr></table>
</div>
</div><p>我们在文件中写入以下内容，然后保存退出：</p>
<pre>
server {
	listen 80;
	server_name belldrum.com;
	root /home/gavin/blog;
	index index.html;
	location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt){
    		root /home/gavin/blog;
	}
</pre>  
<p>最后检查<code>nginx.conf</code>的http块内是否已经正确引用即可。</p>
<pre>
http {
	···
	include /etc/nginx/conf.d/*.conf;
	···
}
</pre>
<a class="post-dummy-target" id="配置-ssl"></a><h2>配置 SSL</h2>
<p>没有配置ssl加密的网站会被大多数浏览器标记为不安全，而且很多授信的证书授权中心也都提供免费的SSL安全证书，因此给自己的网站添加一把小绿锁势在必行。如果你使用的是阿里云，那么在控制面板就可以申请到免费的SSL证书（这不是广告，阿里云，打钱！！）。<br>
<br />
如何申请证书不是本节重点，假设你已经拥有了一份有效的SSL安全证书，私钥文件和证书文件分别为<code>belldrum.com.key</code>和<code>belldrum.com.pem</code>。<br>
<br />
我们在<code>/etc/nginx</code>目录下新建一个<code>cert</code>文件夹用于存放私钥和证书。网站证书里面包含公钥，它是公开的，会发送给每一个连接服务器的客户；私钥需要保存在有权限限制的文件中，并保证nginx主进程拥有可读权限。准备完成后，我们再次修改<code>belldrum.com.conf</code>文件，修改后的内容如下：</p>
<pre>
server {
	listen 443 ssl;						//监听443端口，并添加ssl参数
	server_name belldrum.com; 
	root /home/gavin/blog;
	index index.html;

	ssl_certificate /etc/nginx/cert/belldrum.com.pem;	//证书路径
	ssl_certificate_key /etc/nginx/cert/belldrum.com.key;	//私钥路径
	
	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;

	location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt){
		root /home/gavin/blog;
	}
}
</pre>
<p>其中<code>listen</code>、<code>ssl_certificate</code>和<code>ssl_certificate_key</code>是必须明确说明的。<code>ssl_protocols</code>和<code>ssl_ciphers</code>指令用于要求客户端建立连接时，只使用加强版本的SSL/TLS和加密算法，在没有显式配置时它们的默认值如下：</p>
<pre>
ssl_protocols TLSv1 TLSv1.1 TLSv1.2
ssl_ciphers HIGH：！aNULL：！MD5  
</pre>
<p>我们简单介绍一下什么是SSL/TLS。SSL (Secure Sockets Layer，安全套接字层) 是一种标准安全协议，用于在在线通信中建立Web服务器和浏览器之间的加密链接；TLS (Transport Layer Security) 是SSL协议的升级版，TLS 1.0通常被认为是SSL 3.1，TLS 1.1即为SSL 3.2，TLS 1.2即为SSL 3.3，两者合称为SSL/TLS。我们只要知道它是一种用于加密的安全协议就好了。HTTP协议用来传输数据，SSL/TLS用于加密传输内容，两者结合就是现在所用的HTTPS。</p>
<p><code>HIGH：！aNULL：！MD5</code>指明了服务器可用的SSL/TLS加密套件 (CipherSuite)，如<code>!MD5</code>意为该算法不可用。我们可以使用<code>openssl ciphers -V 'HIGH:!aNULL:!MD5'</code>命令来查看一下具体支持的加密套件，根据OpenSSL版本不同可能略有区别。举个例子：</p>
<pre>
0xC0,0x23 - ECDHE-ECDSA-AES128-SHA256 TLSv1.2 Kx=ECDH Au=ECDSA Enc=AES(128) Mac=SHA256
</pre>
<ul>
<li>名字为 ECDH-ECDSA-AES128-SHA256 的加密套件，用于 TLSv1.2</li>
<li>密钥交换算法（Key Exchange）使用ECDH</li>
<li>认证算法（Authentication）使用ECDSA</li>
<li>加密算法（Encryption）使用AES-128</li>
<li>消息认证码算法（Message Authentication Code, MAC）使用SHA256</li>
</ul>
<p>加密套件是SSL握手中需要协商的一个重要参数。客户端会在<code>Client Hello</code>中带上它所支持的加密套件列表，服务端从中选择一个并通过<code>Server Hello</code>返回。如果两者支持的加密套件列表没有交集会导致握手失败。服务器在选择算法时会有优先级，是以客户端提供的优先还是服务器端配置的优先。可以通过<code>ssl_prefer_server_ciphers on;</code>设置为服务器端优先。<br>
<br />
最后，保存配置文件并退出，重启nginx服务即可通过<code>https://belldrum.com</code>访问网站了。</p>
<a class="post-dummy-target" id="设置跳转"></a><h2>设置跳转</h2>
<p>我们希望当用户使用<code>http</code>访问网站时能够自动重定向到<code>https</code>，或者更进一步，能够同时实现子域名<code>www</code>到<code>non-www</code>的重定向。<br>
<br />
我们可以使用<code>rewrite</code>或者<code>301</code>重定向实现这种跳转，在这里只介绍<code>301</code>重定向的方法。<br>
我们将<code>belldrum.com.conf</code>配置文件修改如下：</p>
<pre>
server {
	listen 443 ssl;
	server_name belldrum.com; 
	root /home/gavin/blog;
	index index.html;

	ssl_certificate /etc/nginx/cert/belldrum.com.pem;
	ssl_certificate_key /etc/nginx/cert/belldrum.com.key;

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
	ssl_prefer_server_ciphers on

	access_log /var/log/nginx/belldrum.com-access.log;
	error_log /var/log/nginx/belldrum.com-error.log;

	location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt){
		root /home/gavin/blog;
	}
}

server {	//设置http重定向到https
	listen 80;
	server_name belldrum.com www.belldrum.com;
	return 301 https://belldrum.com$request_uri;
}

server {	//设置www重定向到non-www
        listen 443 ssl;  
        server_name www.belldrum.com;

        ssl_certificate /etc/nginx/cert/belldrum.com.pem;
        ssl_certificate_key /etc/nginx/cert/belldrum.com.key;
        ssl_prefer_server_ciphers on

        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;

        return 301 https://belldrum.com$request_uri;
}
</pre>
<p>如果是多个域名的话，<code>server_name</code>选项也支持正则表达式。修改完成后保存退出，然后重启nginx服务即可实现跳转。</p>
<a class="post-dummy-target" id="设置hsts"></a><h2>设置HSTS</h2>
<a class="post-dummy-target" id="添加响应头"></a><h3>添加响应头</h3>
<p><ruby><rb>HTTP严格传输安全</rb><rt>HTTP Strict Transport Security</rt></ruby>，即HSTS，是由互联网工程任务组发布的互联网安全策略机制。采用HSTS策略的网站会强制浏览器使用HTTPS而不是HTTP访问当前资源，以减少会话劫持风险、保护网站流量。
<br /><br>
网站第一次通过HTTPS请求时，服务器响应<code>Strict-Transport-Security</code>头，浏览器记录下这些信息然后在规定时间内访问这个网站的请求都会自动把HTTP替换为HTTPS，并忽略其它的跳转设置(如301重定向跳转)。</p>
<p>当HSTS响应头(Response Header)设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。每次浏览器接收到STS头，它都会更新这个网站的过期时间，防止过期发生。
<br /><br>
HSTS响应头的语法如下：</p>
<pre>
Strict-Transport-Security: max-age=<expire-time>[; includeSubDomains][; preload;]	
</pre>
<p>选项说明：</p>
<ul>
<li><code>max-age=&lt;expire-time&gt;</code> 浏览器收到这个请求后，在<code>&lt;expire-time&gt;</code>秒内访问该域名下的请求都使用HTTPS</li>
<li><code>includeSubDomains</code> 可选项，如果添加这个参数，那么说明此规则也适用于该网站的所有子域名</li>
<li><code>preload</code> 可选项，将域名申请添加到 <a href="#%e9%a2%84%e5%8a%a0%e8%bd%bd%e5%88%97%e8%a1%a8">预加载HSTS列表</a><br>
<br /></li>
</ul>
<p>在nginx中设置HSTS响应头非常简单，只需要在监听443端口的server中加入以下内容：</p>
<pre>
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
</pre>
<ul>
<li><code>always</code>参数确保为所有响应（包括内部生成的错误响应）设置HSTS响应头</li>
</ul>
<p>向客户提供HSTS策略后，它将在指定<code>&lt;expire-time&gt;</code>秒内缓存信息。在此期间，浏览器拒绝通过未加密的HTTP访问Web服务，同时也拒绝网站证书错误，而不会给用户继续访问的选择。如果指定了<code>includeSubDomains</code>参数，那么这些限制也适用于该域名的所有子域名。</p>
<p>撤消HSTS策略以删除网站或服务的HTTPS版本非常困难。因此在测试阶段，请先使用非常短的<code>max-age</code>时间，例如设置为5分钟(<code>max-age=300</code>)，并在测试没有问题时逐渐延长为一周、一月或一年(<code>max-age=31536000</code>为一年)。
<br /><br>
修改后的<code>belldrum.com.conf</code>配置文件如下：</p>
<pre>
server {
	listen 443 ssl;		//监听所有ipv4地址
	listen [::]:443 ssl;	//监听所有ipv6地址
	server_name belldrum.com;

	add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
 
	root /home/gavin/blog;
	index index.html;

	ssl_certificate /etc/nginx/cert/belldrum.com.pem;
	ssl_certificate_key /etc/nginx/cert/belldrum.com.key;

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
	ssl_prefer_server_ciphers on

	access_log /var/log/nginx/belldrum-access.log;
	error_log /var/log/nginx/belldrum-error.log;

	location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt){
		root /home/gavin/blog;
	}
}

server {
	listen 80;
	listen [::]:80;	
	server_name belldrum.com www.belldrum.com;
	return 301 https://belldrum.com$request_uri;
}

server {
        listen 443 ssl;  
        listen [::]:443 ssl;
        server_name www.belldrum.com;

        ssl_certificate /etc/nginx/conf.d/cert/3492990_belldrum.com.pem;
        ssl_certificate_key /etc/nginx/conf.d/cert/3492990_belldrum.com.key;
        
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_prefer_server_ciphers on

        return 301 https://belldrum.com$request_uri;
}
</pre>
<a class="post-dummy-target" id="预加载列表"></a><h3>预加载列表</h3>
<p>HSTS并不能完美的解决HTTP会话劫持，它也有一些缺点。如果用户在以下情况通过HTTP访问受HSTS保护的网站，仍然容易受到攻击：</p>
<ul>
<li>从未访问过该网站</li>
<li>切换新的浏览器</li>
<li>切换新设备或系统</li>
<li>删除了浏览器缓存</li>
<li>近期没有访问该网站，max-age已过期</li>
</ul>
<p>为了解决这个问题，Google维护了一份 <a href="https://hstspreload.org/" target="_blank">预加载列表</a> (HSTS Preload List)。我们可以手动将自己的域名提交到HSTS预加载列表，然后这个列表会被硬编码到Chrome浏览器中。同时大多数主流浏览器，如 Firefox、Opera、Safari、Safari、IE 11和Edge等也支持该HSTS预加载列表。</p>
<p>提交HSTS预加载列表之前网站需要满足以下几点要求：</p>
<ul>
<li>提供有效的证书</li>
<li>如果正在监听80端口，则需要在同一主机上将HTTP重定向到HTTPS</li>
<li>通过HTTPS服务所有的子域名，特别是www子域名</li>
<li>HSTS头中的参数要求<code>max-age</code>至少为31536000(一年)，且必须包含<code>includeSubDomains</code>和<code>preload</code>参数</li>
</ul>
<p>需要注意的是，从预加载列表中删除自己的域名非常困难，可能需要几个月的时间才能使用户更新。因此，除非确定可以长期支持整个站点和其子域名的HTTPS服务，否则不要申请加入该列表。</p>
<a class="post-dummy-target" id="https优化"></a><h2>HTTPS优化</h2>
<p>SSL操作会消耗额外的CPU资源</p>
<a class="post-dummy-target" id="减少运算量"></a><h3>减少运算量</h3>
<a class="post-dummy-target" id="加强安全性"></a><h3>加强安全性</h3>
<a class="post-dummy-target" id="参考资料"></a><h2>参考资料</h2>
<pre>
add_header Strict-Transport-Security "max-age=2592000; includeSubDomains; preload";
add_header X-Frame-Options DENY;
add_header X-Content-Type-Options nosniff;
add_header Content-Security-Policy "default-src 'self' www.google-analytics.com ajax.googleapis.com www.google.com google.com gstatic.com www.gstatic.com connect.facebook.net facebook.com;";
add_header X-XSS-Protection "1; mode=block";
add_header Referrer-Policy "origin";
</pre></div><div class="post-footer">
        <a href="https://belldrum.com/2020/02/0007-nginx/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/nginx/"><i class="fas fa-tag fa-fw"></i>&nbsp;Nginx</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2020/02/0005-linux-user-management/">Linux 之权限管理</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=2020-02-16>2020-02-16</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="https://belldrum.com/categories/linux/">Linux</a></span></div><div class="post-content"><p>Linux系统是一个多用户多任务的分时操作系统，每一个需要使用系统资源的用户都需要先由系统管理员创建一个账号，然后以该账号的身份和口令登入系统。</p>
<p>用户的账号既有助于系统管理员控制用户对系统资源的访问权限，也有助于帮助用户组织文件，并为用户提供安全性、隐私性的保护。</p>
<a class="post-dummy-target" id="文件基本属性"></a><h2>文件基本属性</h2>
<p>在学习Linux用户管理之前，我们先来了解关于文件的一些基本概念。<br>
在Linux系统中有一个基本思想，即“一切皆文件”。控制文件的访问权限非常重要，Linux中针对每一个文件都有属主(User/Owner)、属组(Group)和其他组(Other)的概念，藉此可以管理不同用户访问同一文件的权限。<br>
<br />
在Linux系统中，我们可以使用<code>ls -l</code>命令来显示一个文件的属性及其所属的用户和组，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@guoc:/# ls -l
total <span class="m">7</span>
...
drwxrw-r-- <span class="m">1</span> root root <span class="m">4096</span> Otc <span class="m">18</span> <span class="m">2020</span> bin  
----------   ---- ----                  ---
 类型及权限   属主  属组                 文件
...
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="属性"></a><h3>属性</h3>
<p>首字段<code>drwxrw-r--</code>描述了文件的类型及不同用户的权限(Permission)。</p>
<table>
<thead>
<tr>
<th align="center">文件类型</th>
<th align="center">属主权限</th>
<th align="center">属组权限</th>
<th align="center">其他用户权限</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">d</td>
<td align="center">r w x</td>
<td align="center">r w -</td>
<td align="center">r - -</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1 2 3</td>
<td align="center">4 5 6</td>
<td align="center">7 8 9</td>
</tr>
<tr>
<td align="center">目录文件</td>
<td align="center">读写执行</td>
<td align="center">读写</td>
<td align="center">读</td>
</tr>
</tbody>
</table>
<p>其中，首字符表示文件类型：<br>
<code>d</code>为目录，<code>-</code>为文件，<code>l</code>为链接文档，<code>b</code>为可供存储的接口设备，<code>c</code>为串行端口设备。</p>
<p>接下来的字符中，<code>rwx</code>三个一组，分别表示<code>read</code>、<code>write</code>和<code>execute</code>权限，<code>-</code>表示没有对应的权限。</p>
<p>总体来看，第0位确定文件类型，第1-3位确定属主拥有该文件的权限，
第4-6位确定属组拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<a class="post-dummy-target" id="属主userowner"></a><h3>属主(User/Owner)</h3>
<p>属主是文件的所有者。默认情况下，属主为该文件的创建者，谁创建了这个文件，谁就自然的成为了该文件的所有者。</p>
<a class="post-dummy-target" id="属组group"></a><h3>属组(Group)</h3>
<p>在Linux系统中，用户是按组分类的，一个用户属于一个或多个组，属于同一个组的用户对同一文件拥有相同的访问权限。<br>
当一个用户创建了一个文件后，默认该用户所在的组就是这个文件的属组。通过设定文件的属组，我们可以集中管理属组内所有用户对这个文件的访问权限。</p>
<p><strong>注意：</strong></p>
<ol>
<li>默认情况下，文件的属主和属组分别为该文件的创建者及其所在的用户组，但我们也可以更改文件的属主和属组。因此，一些教程中把文件的属组解释为文件属主所在的组，或者把属组用户解释为与属主同组的用户，这种理解并不正确。</li>
<li>上面的例子中，虽然属主和属组都为root，但是属主字段为<strong>用户</strong><code>uid</code>，属组字段为<strong>用户组</strong><code>gid</code>，前者代表单个用户账号，后者代表账号的集合。我们在创建新用户时，会默认创建一个同名的用户组，但是两者之间并不等价。</li>
<li>对每一个文件来说，除属主以外的用户再划分为属组用户和其他用户，三者之间的权限彼此独立。比如：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">d---rw-r-- <span class="m">1</span> usr usr <span class="m">4096</span> Otc <span class="m">18</span> <span class="m">2020</span> bin
</code></pre></td></tr></table>
</div>
</div><p>假设属主usr的gid为usr，此时属主没有读写执行bin文件的权限，但是与属主同组的其他用户拥有读写bin文件的权限。</p>
</li>
</ol>
<a class="post-dummy-target" id="其他组other"></a><h3>其他组(Other)</h3>
<p>除去文件属主和属组用户以外的用户为其他组用户。</p>
<a class="post-dummy-target" id="文件属性管理"></a><h2>文件属性管理</h2>
<a class="post-dummy-target" id="更改文件属主"></a><h3>更改文件属主</h3>
<p><strong>Root用户</strong>可以使用<code>chown</code>命令更改文件的属主，也可以同时更改文件的属组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chown <span class="o">[</span>-R<span class="o">]</span> User<span class="o">[</span>:Group<span class="o">]</span> <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>[  ]</code>内为可选参数。<br>
-R 为递归更改，当更改目录文件时，加上该参数可以递归更改目录及目录下所有文件的属主。</p>
<a class="post-dummy-target" id="更改文件属组"></a><h3>更改文件属组</h3>
<p><strong>Root用户</strong>和<strong>文件属主</strong>可以使用<code>chgrp</code>命令更改文件属组，前者更改没有限制，后者只可将属组改为自己是其成员的组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chgrp <span class="o">[</span>-R<span class="o">]</span> User <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>-R 为可选参数。当更改目录文件时，加上该参数可以递归更改目录及目录下所有文件的属组。</p>
<a class="post-dummy-target" id="更改文件权限"></a><h3>更改文件权限</h3>
<p><strong>Root用户</strong>和<strong>文件属主</strong>可以使用<code>chmod</code>命令更改文件权限。<br>
更改文件权限有两种方式，分别为数字模式(Numeric Mode)和符号模式(Symbolic Mode)。</p>
<a class="post-dummy-target" id="数字模式"></a><h4>数字模式</h4>
<p>数字模式中<code>r``w``x</code>权限分别用分数表示：</p>
<ul>
<li><code>r</code>：4</li>
<li><code>w</code>：2</li>
<li><code>x</code>：1</li>
</ul>
<p>三种权限的分数累加之和代表User、Group和Other用户的权限。举个例子，<code>[-rwxrw----]</code>分数计算如下：</p>
<ul>
<li><code>User = rwx = 4 + 2 + 1 = 7</code></li>
<li><code>Group = rw- = 4 + 2 + 0 = 6</code></li>
<li><code>Other = --- = 0 + 0 + 0 = 0</code></li>
</ul>
<p>因此，该文件的权限数字可以用<code>760</code>表示。<br>
更改权限的时我们输入如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod <span class="o">[</span>-R<span class="o">]</span> xyz <span class="o">{</span>File<span class="p">|</span>Directory...<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中xyz就是按照上述方法计算出的用户权限。</p>
<a class="post-dummy-target" id="符号模式"></a><h4>符号模式</h4>
<p>符号模式中使用<code>u</code>，<code>g</code>，<code>o</code>分别表示<code>User</code>，<code>Group</code>，<code>Other</code>，用<code>a</code>来表示<code>All</code>，即全部的身份。此外，使用<code>+</code>，<code>-</code>，<code>=</code>分别表示添加、除去和设定权限。</p>
<p>举个例子，我们设定<code>test</code>文件的权限为<code>-rwxr-xr--</code>，可以使用以下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod <span class="nv">u</span><span class="o">=</span>rwx,g<span class="o">=</span>rx,o<span class="o">=</span>r <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><p>现在我们使用以下命令，除去<code>test</code>文件所有用户的执行权限：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">chmod a-x <span class="nb">test</span>
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="用户管理"></a><h2>用户管理</h2>
<p>Linux是一个多用户的操作系统，支持多个用户同时登录。用户角色可分为三类，分别为root用户、伪用户和普通用户。<br>
<br />
Root用户系统唯一，具有系统的最高权限，可以操作任何的文件和命令。<br>
伪用户是系统运行必不可少的用户，比如bin、daemon、adm、ftp、mail等用户。这些用户通常都是系统自身拥有的，不具备登录系统的能力。<br>
普通用户和root用户一样，都是真实用户，可以登录系统。但是普通用户的权限有限，通常都是由系统管理员自行添加。<br>
<br />
用户账号的管理主要涉及到用户账号的添加、修改和删除，我们来分别介绍这几部分的内容。</p>
<a class="post-dummy-target" id="添加新用户账号"></a><h3>添加新用户账号</h3>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。<br>
通过使用<code>useradd</code>命令添加新的用户账号，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">useradd <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-c</code> comment 指定一段注释性描述</li>
<li><code>-d</code> 指定用户主目录，如果此目录不存在，添加-m选项可以创建主目录</li>
<li><code>-g</code> 指定用户所属的用户组 </li>
<li><code>-G</code> 指定用户所属的附加组，有多个附加组则用逗号隔开</li>
<li><code>-s</code> 指定用户的登录Shell</li>
<li><code>-u</code> 指定用户的用户号</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">useradd -d /home/gavin -m -s /bin/bash -g group -G root,adm gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令添加了一个名为<code>gavin</code>的新用户，<code>-d</code>和<code>-m</code>选项为该用户创建了主目录<code>/home/gavin</code>，登录shell为<code>bash</code>，他属于<code>group</code>用户组，同时也属于<code>root</code>和<code>adm</code>用户组，其中<code>group</code>是他的主用户组。<br>
<br />
添加新用户账号就是系统在/etc/passwd文件中增加一条新纪录，同时更新其他系统文件，如/etc/group和/etc/shadow等，详细介绍见第五节<a href="#%e7%94%a8%e6%88%b7%e5%92%8c%e7%94%a8%e6%88%b7%e7%bb%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">「用户和用户组配置文件」</a>。</p>
<a class="post-dummy-target" id="指定或修改用户密码"></a><h3>指定或修改用户密码</h3>
<p>刚创建的用户没有密码，被系统锁定无法使用，需要为其指定密码后才可以使用，即使是指定空的密码。<br>
使用<code>passwd</code>命令指定或修改用户密码，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">passwd <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-l</code> 锁定密码，禁用账号</li>
<li><code>-u</code> 密码解锁</li>
<li><code>-d</code> 使账号没有密码</li>
<li><code>-f</code> 强迫用户下次登录时修改密码</li>
<li>如果username为空，则默认修改当前用户的密码</li>
</ul>
<a class="post-dummy-target" id="修改用户"></a><h3>修改用户</h3>
<p>修改用户账号就是根据实际业务需求更改用户的相关书信，如用户组、登录Shell等。<br>
使用<code>usermod</code>命令修改用户属性，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">usermod <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-l newname</code> 修改用户名</li>
<li>其它可参考<code>useradd</code>命令，如<code>-d</code>，<code>-g</code>，<code>-a -G</code>，<code>-s</code>。</li>
</ul>
<a class="post-dummy-target" id="删除用户"></a><h3>删除用户</h3>
<p>我们可以使用<code>userdel</code>命令执行删除用户的操作，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">userdel <span class="o">[</span>option<span class="o">]</span> username
</code></pre></td></tr></table>
</div>
</div><p>常用的选项是<code>-r</code>，它的作用是将该用户的主目录一起删除，不添加的话会保留该用户的主目录。<br>
举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">userdel -r gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令会删除用户<code>gavin</code>在系统文件，如/etc/passwd，/etc/shadow，/etc/group中的相应记录，同时删除用户的主目录。</p>
<a class="post-dummy-target" id="用户组管理"></a><h2>用户组管理</h2>
<p>用户组是具有相同权限的一组用户，通过用户组我们可以集中管理用户组中所有用户的权限。<br>
默认情况下，Linux系统中创建的用户属于与它同名的用户组，这个用户组在创建用户时同时建立。<br>
用户组的管理主要包括用户组的添加、删除和修改，本质上是对/etc/group文件的更新。</p>
<a class="post-dummy-target" id="增加用户组"></a><h3>增加用户组</h3>
<p>使用<code>groupadd</code>命令增加新的用户组，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupadd <span class="o">[</span>-g<span class="o">]</span> groupname
</code></pre></td></tr></table>
</div>
</div><p>举个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupadd -g <span class="m">100</span> gavin
</code></pre></td></tr></table>
</div>
</div><p>我们在系统中添加了一个名为<code>gavin</code>的新用户组，并指定新组的组标识号gid为100；如果不添加-g参数，那么新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<a class="post-dummy-target" id="修改用户组"></a><h3>修改用户组</h3>
<p>修改用户组属性使用<code>groupmod</code>命令，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupmod <span class="o">[</span>option<span class="o">]</span> group
</code></pre></td></tr></table>
</div>
</div><p>选项说明：</p>
<ul>
<li><code>-g</code> 为用户指定新的组标识号</li>
<li><code>-n newgroup</code> 将用户组名改为新名字<br>
举个例子：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupmod -g <span class="m">2020</span> -n kavin gavin
</code></pre></td></tr></table>
</div>
</div><p>该命令将gavin用户组更名为kavin，并将组标识号改为2020。</p>
<a class="post-dummy-target" id="删除用户组"></a><h3>删除用户组</h3>
<p>删除用户组使用<code>groupdel</code>命令，语法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">groupdel group
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="用户和组配置文件"></a><h2>用户和组配置文件</h2>
<p>在Linux系统中，与用户和用户组相关的信息保存在一些系统文件中，主要包括以下三个文件:</p>
<ul>
<li><code>/etc/passwd</code></li>
<li><code>/etc/group</code></li>
<li><code>/etc/shadow</code></li>
</ul>
<p>而前文所述的针对用户与用户组的管理，本质上是对这些文件中的相应信息进行修改，接下来让我们详细介绍一下这几个文件。</p>
<a class="post-dummy-target" id="passwd文件"></a><h3>passwd文件</h3>
<p><code>/etc/passwd</code>文件存储了当前系统中所有用户的信息。文件的每一行记录都对应着系统中的一个用户，记录了这个用户的一些基本属性。</p>
<p>文件的内容类似于下面的例子：</p>
<pre>
root&#58;x:0:0:root:/root:/bin/bash  
daemon&#58;x:1:1:daemon:/usr/sbin:/usr/sbin/nologin  
bin&#58;x:2:2:bin:/bin:/usr/sbin/nologin  
sys&#58;x:3:3:sys:/dev:/usr/sbin/nologin  
···
</pre>  
<p>文件中每个用户的信息格式是固定的，每行记录用（:）分隔为七个字段，每个字段的说明如下：</p>
<table>
<thead>
<tr>
<th align="center">user:</th>
<th align="center">x:</th>
<th align="center">123:</th>
<th align="center">456:</th>
<th align="center">xxx:</th>
<th align="center">/home/user:</th>
<th align="center">/bin/bash</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">用户名</td>
<td align="center">密码占位符</td>
<td align="center">UID</td>
<td align="center">GID</td>
<td align="center">注释性描述</td>
<td align="center">主目录</td>
<td align="center">登录Shell</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="shadow文件"></a><h3>shadow文件</h3>
<p>由于/etc/passwd文件所有用户都可读，用户的密码太简单或规律比较明显会被轻易破解。因此Linux系统中把加密后的密码分离出来，单独保存放在<code>/etc/shadow</code>文件中。只超级用户才拥有该文件的读取权限，保证了用户密码的安全性。</p>
<p>shadow文件中的记录与passwd中的用户记录一一对应，记录格式也类似，由（:）分割成的多个字段组成。</p>
<p>举个例子：</p>
<pre>
root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::  
</pre>
<p>字段说明如下：</p>
<p><code>登录名:加密密码:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></p>
<a class="post-dummy-target" id="group文件"></a><h3>group文件</h3>
<p>用户和用户组之间存在一对一、一对多和多对一的关系。<br>
在<code>passwd</code>文件中记录的是用户所属的主组，即登录时所属的默认组。除主组以外，用户也可以属于其他多个组，这些组称为用户的附加组。<br>
用户组的信息保存在<code>/etc/group</code>文件中，文件内容的格式与<code>passwd</code>相似，也是由（:）隔开的字段组成，举个例子：</p>
<pre>
root&#58;x:0:root
bin&#58;x:2:root,bin
sys&#58;x:3:root,uucp
···
gavin&#58;x:5:gavin,kavin 
</pre>  
<p>各个字段的说明如下：<br>
<code>组名:密码:组标识号(GID):组内用户列表</code></p>
<p>此外，用户组也有一个对应的<code>/etc/gshadow</code>文件保存用户组密码，在此不作具体介绍。</p>
<a class="post-dummy-target" id="常用命令总结"></a><h2>常用命令总结</h2>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>chmod [option] file</code></td>
<td align="left">修改文件权限</td>
</tr>
<tr>
<td align="left"><code>chown user file</code></td>
<td align="left">修改文件属主</td>
</tr>
<tr>
<td align="left"><code>chgrp group file</code></td>
<td align="left">修改文件属组</td>
</tr>
<tr>
<td align="left"><code>whoami</code></td>
<td align="left">查询当前登录用户名</td>
</tr>
<tr>
<td align="left"><code>id user</code></td>
<td align="left">查询指定用户信息，包括<code>uid</code>、<code>gid</code>和<code>groups</code><br />如果不指定用户名则显示当前登录用户信息</td>
</tr>
<tr>
<td align="left"><code>groups user</code></td>
<td align="left">查询指定用户所属的组，显示的第一个组是当前用户的主要组<br />如果不指定用户名则显示当前登录用户所属的组</td>
</tr>
<tr>
<td align="left"><code>newgrp group</code></td>
<td align="left">如果用户同时属于多个用户组，该命令用于当前登录用户在不同组间切换，<br/>以便具有其他用户组的权限，切换的组必须是当前用户的主组或附加组</td>
</tr>
<tr>
<td align="left"><code>su user</code></td>
<td align="left">切换登录用户，不指定用户名则切换为root用户<br />切换后$表示普通用户，#表示超级用户</td>
</tr>
<tr>
<td align="left"><code>useradd [option] user</code></td>
<td align="left">添加新用户</td>
</tr>
<tr>
<td align="left"><code>passwd [option] user</code></td>
<td align="left">指定或修改用户密码，添加新用户后需指定密码后才可使用</td>
</tr>
<tr>
<td align="left"><code>usermod [option] user</code></td>
<td align="left">修改用户信息</td>
</tr>
<tr>
<td align="left"><code>userdel [-r] user</code></td>
<td align="left">删除指定用户，-r删除用户主目录</td>
</tr>
<tr>
<td align="left"><code>groupadd group</code></td>
<td align="left">添加新用户组</td>
</tr>
<tr>
<td align="left"><code>groupdel group</code></td>
<td align="left">删除指定用户组</td>
</tr>
<tr>
<td align="left"><code>groupmod group</code></td>
<td align="left">修改指定用户组</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="待补充问题"></a><h2>待补充问题</h2>
<ol>
<li>
<p>添加新用户后，切换到该用户只显示一个<code>$</code>符号，而不是常见的<code>user@***</code>的格式；而且一些命令，如<code>ll</code>也无法使用，请问为什么？</p>
<p>解决办法：将用户登录Shell设置为/bin/bash即可。</p>
</li>
<li>
<p>从权限高的用户切换到权限低的用户不需要输入密码，反之需要。</p>
</li>
</ol></div><div class="post-footer">
        <a href="https://belldrum.com/2020/02/0005-linux-user-management/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/linux/"><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2020/02/0003-ali-cloud-server/">阿里ECS实例配置</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=0001-01-01>0001-01-01</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="https://belldrum.com/categories/server/">Server</a></span></div><div class="post-content"><p>趁着过年期间阿里云的新客活动，忍痛购买了3年的ECS云服务器，顺便可以给自己的域名挂上良民证，奥利给！</p>
<p>但是由于今年疫情的原因，备案时间会比较长，据说需要20天左右。而且之前一直只是在用Linux Client，于是趁着备案期间先熟悉一下阿里云Linux Server的使用和设置，下面是一些零零散散的踩坑记录。</p>
<a class="post-dummy-target" id="密码"></a><h2>密码</h2>
<p>管理密码是一件非常头疼的事情，每次设置完密码都会陷入沉思，&ldquo;woc&hellip;马什么梅来?&quot;。<br>
ECS实例创建后主要使用的有两个密码，分别是实例密码和远程连接密码。</p>
<ul>
<li>实例密码<br>
实例密码是Linux操作系统的密码，就是Root用户密码。奇怪的是创建实例时没有任何初始密码的提示，我是在创建完成后在服务控制台进行的密码重置，需要注意的是重置密码需要重启实例后才会生效。</li>
<li>远程连接密码<br>
远程连接密码是指阿里云控制台自带的远程连接工具的密码，这个密码最初是系统自动生成的6位数字，用户可以自定义修改这个远程连接密码。</li>
</ul>
<p>事实上，如果我们不使用阿里云控制台自带的VNC远程连接工具，那么就用不到远程连接密码。更改远程连接密码无需重启直接生效；实例密码是Linux系统下的root密码，Windows系统下的administrator密码，修改实例密码必须重启实例才可以生效。</p>
<a class="post-dummy-target" id="网络"></a><h2>网络</h2>
<p>阿里云面向客户提供的网络类型服务有经典网络和专有网络两种，官方文档给的解释是：</p>
<ul>
<li>经典网络<br>
ip地址由阿里云统一分配，配置简便，使用方便，适合对操作易用性要求比较高、需要快速使用 ECS 的用户。</li>
<li>专有网络<br>
是指逻辑隔离的私有网络，您可以自定义网络拓扑和 ip 地址，支持通过专线连接。适合于熟悉网络管理的用户。</li>
</ul>
<p>我们通俗点理解就是，经典网络和专有网络公网使用同一个公网ip。但是从内网ip来看，经典网络是DHIP，也就是系统自动分配局域网ip地址，而专有网络则是手动分配局域网ip地址，方便有多台云服务器的用户自行定义内网ip结构。所以，如果我们只有一台服务器，或者有多台服务器但不需要进行内网互联，那么这两种网络任选一个就可以了。官方推荐使用专有网络。</p>
<a class="post-dummy-target" id="带宽"></a><h2>带宽</h2>
<ul>
<li>入网带宽（上行带宽）<br>
流入云服务器ECS的带宽，例如：
<ul>
<li>云服务器ECS下载外部网络资源</li>
<li>FTP客户端上传资源到云服务器ECS</li>
</ul>
</li>
<li>出网带宽（下行带宽）<br>
流出云服务器ECS的带宽，例如：
<ul>
<li>云服务器ECS对外提供访问</li>
<li>FTP客户端下载云服务器ECS内部资源</li>
</ul>
</li>
</ul>
<a class="post-dummy-target" id="安全组"></a><h2>安全组</h2>
<p>安全组是ECS实例的虚拟防火墙，用于设置实例的网络访问控制，允许或拒绝公网请求和内网请求。<br>
安全组具备状态检测和数据包过滤功能，可以设置单台或多台云服务器的网络访问控制。<br>
<br />
每个实例必须属于至少一个安全组，一个安全组可以包括多个实例。同一安全组内的实例之间默认内网互通，不同安全组的实例之间默认内网不通，可以授权两个安全组之间互访。<br>
在创建实例时，系统会提供一个默认安全组，默认安全组中的默认规则仅设置针对ICMP协议、SSH 22端口、RDP 3389端口、HTTP 80端口和HTTPS 443端口的入方向规则。<br>
<br />
我们也可以自行创建一个安全组并添加满足自己业务需求的安全组规则，自行创建的安全组在未添加任何安全组规则之前，出方向允许所有访问，入方向拒绝所有访问。</p>
<a class="post-dummy-target" id="添加规则"></a><h3>添加规则</h3>
<p>一般场景下我们需要设置的选项主要有两个：端口范围和授权对象，其他可参考默认设置。</p>
<ul>
<li>端口范围<br>
端口取值范围从1到65535，设置格式例如1/200或者80/80，其中“-1/-1”不能单独设置，代表不限制端口。</li>
<li>授权对象<br>
可以填写单个ip地址，例如223.78.253.196/32，填写0.0.0.0/0表示允许/拒绝全网段访问指定端口。<br>
可以填写多个ip地址，彼此之间用逗号隔开。<br>
此外还可以指定ip地址段，如 223.78.253.196/31，这将会授权/拒绝223.78.253.196和223.78.253.197的连接。</li>
</ul>
<a class="post-dummy-target" id="规则优先级"></a><h3>规则优先级</h3>
<p>同类型规则间依赖优先级（手动建立1-100，系统建立110）决定最终执行的规则。当ECS实例加入了多个安全组时，多个安全组会从高到低依次匹配规则。优先级取值范围如下所示，数值越小，优先级越高。</p>
<a class="post-dummy-target" id="实践建议"></a><h3>实践建议</h3>
<ul>
<li>仅允许少量请求访问ECS实例时，可以将安全组作为白名单使用。即先设置安全组为拒绝全部访问，然后逐一添加允许通信的访问请求策略。</li>
<li>选择开放具体的端口，如80/80端口，不要设置为端口范围。</li>
<li>添加安全组规则时，谨慎授权0.0.0.0/0（全网段）访问源。</li>
</ul>
<a class="post-dummy-target" id="一个例子"></a><h3>一个例子</h3>
<p>如果您在实例上架设了一个网站，希望您的用户能通过HTTPS服务访问到您的网站，您需要在实例所在安全组中添加以下安全组规则。</p>
<table>
<thead>
<tr>
<th align="center">网络类型</th>
<th align="center">网卡类型</th>
<th align="center">规则方向</th>
<th align="center">授权策略</th>
<th align="center">协议类型</th>
<th align="center">端口范围</th>
<th align="center">授权类型</th>
<th align="center">授权对象</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">VPC</td>
<td align="center">不需要配置</td>
<td align="center">入方向</td>
<td align="center">允许</td>
<td align="center">HTTPS</td>
<td align="center">443</td>
<td align="center">地址段访问</td>
<td align="center">0.0.0.0/0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">经典网络</td>
<td align="center">公网</td>
<td align="center">入方向</td>
<td align="center">允许</td>
<td align="center">HTTPS</td>
<td align="center">443</td>
<td align="center">地址段访问</td>
<td align="center">0.0.0.0/0</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<a class="post-dummy-target" id="远程连接"></a><h2>远程连接</h2>
<p>Secure Shell（SSH）是一种加密网络协议，通过对传输内容进行加密在不安全的网络上安全地操作网络服务，常用于用户远程登录到计算机系统，详细请戳<a href="https://belldrum.com/2020/02/0009-ssh-intro2/" target="_blank">「SSH 原理 &amp; 实践」</a>。<br>
<br />
连接之前我们需要确认安全组中已开放22端口，确认之后我们可以通过用户名密码验证和SSH密钥对验证两种方式远程连接服务器实例。密钥验证相对更加安全，而且阿里云密钥验证的设置也非常简便，直接在控制台中即可一键完成，因此我们推荐使用密钥认证的方式连接服务器。<br>
<br />
首先在 <code>云服务控制台 &gt; 网络与安全 &gt; 密钥对</code> 中创建密钥对并绑定实例，该密钥由ECS生成，默认采用RSA 2048位的加密方式。密钥绑定后，公钥会自动分发给绑定的实例，我们只需要把私钥保存到本地，然后便可通过XShell等工具连接实例了。<br>
<br />
绑定和解绑密钥时需要注意：</p>
<ul>
<li>如果使用SSH密钥对登录Linux实例，将会禁用密码登录，以提高安全性。<br>
如果在绑定密钥对之后想使用密码方式登录实例，可以通过重置实例密码实现。如果在绑定密钥对之后重置了实例密码，使用密钥对方式和使用密码方式均能登录实例。</li>
<li>基于数据安全考虑，在实例状态为运行中（Running）时绑定或者解绑密钥对，我们需要重启实例使操作生效。</li>
</ul>
<a class="post-dummy-target" id="防火墙"></a><h2>防火墙</h2>
<p><strong>特别提醒</strong><br>
<u>远程使用ufw注意开启远程连接的端口，或者在测试时设置定时关闭防火墙的脚本，防止自己连接不上</u><br>
<br />
UFW，即<ruby><rb>简单防火墙</rb><rt>uncomplicated firewall</rt></ruby>，是Ubuntu下的一个简易防火墙配置工具。<br>
UFW是iptables的前端，简化了iptables复杂的配置过程，使用起来很方便。默认情况下UFW是没有开启的，我们通过以下命令可以启动UFW：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw <span class="nb">enable</span>
ufw default deny
</code></pre></td></tr></table>
</div>
</div><p>其中第一条命令是启动ufw，并设置为开机启动；第二条命令是使用ufw默认的规则，即关闭所有的外部对本机的访问，但本机访问外部正常。<br>
我们也可以关闭ufw和开机启动，命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw disable
</code></pre></td></tr></table>
</div>
</div><p>使用allow命令打开指定的端口，举个例子，我们打开22和80端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw allow <span class="m">22</span>
ufw allow <span class="m">80</span>
</code></pre></td></tr></table>
</div>
</div><p>指定允许来自某一个ip或网段的连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw allow from 192.168.1.1/24
</code></pre></td></tr></table>
</div>
</div><p>使用<code>delete allow</code>删除已经添加过的规则，举个例子，我们禁用80端口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw delete allow <span class="m">80</span>
</code></pre></td></tr></table>
</div>
</div><p>规则设置完成后，我们可以重新加载来使规则生效（不重新加载也会生效?），命令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw reload
</code></pre></td></tr></table>
</div>
</div><p>现在可以通过以下命令查看防火墙的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw status
</code></pre></td></tr></table>
</div>
</div><p>我们配置了很多规则，但是现在需要抛弃它们重新配置，我们可以这么做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">ufw reset
</code></pre></td></tr></table>
</div>
</div><p>更多配置选项可以参考UFW手册 <code>man ufw</code>。</p></div><div class="post-footer">
        <a href="https://belldrum.com/2020/02/0003-ali-cloud-server/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/server/"><i class="fas fa-tag fa-fw"></i>&nbsp;Server</a>
                    </span><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/ubuntu/"><i class="fas fa-tag fa-fw"></i>&nbsp;Ubuntu</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2020/02/0001-hugo-concise-tutorial/">Hugo&#43;Github=?</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=2020-02-03>2020-02-03</time>&nbsp;<span class="post-category">收录于&nbsp;<i class="far fa-folder fa-fw"></i>
                        <a href="https://belldrum.com/categories/server/">Server</a></span></div><div class="post-content"><p>Hugo是由GO语言实现的静态网站生成器，自称“The world&rsquo;s fastest framework for building websites”。</p>
<p>静态网站的好处是快速、安全和易于部署，最主要的是可以利用版本控制系统来进行管理。<br>
本文主要介绍如何使用Hugo快速搭建静态网站以及如何使用Github Pages免费托管。</p>
<a class="post-dummy-target" id="step-1-install-hugo"></a><h2>Step 1: Install Hugo</h2>
<p>在release<a href="https://github.com/gohugoio/hugo/releases" target="_blank"><u>下载</u></a> 对应版本的二进制文件，二进制版本的好处是无需安装额外依赖。下载完成后解压获得hugo.exe文件，然后将其所在路径添加到环境变量PATH中，方便在命令行中使用。</p>
<p>添加成功后，在cmd中输入<code>hugo version</code>检查是否安装成功，如果安装成功会输出<br>
<code>Hugo Static Site Generator v0.63.2-934EE21F windows/amd64 BuildDate: 2020-01-27T12:14:15Z</code>。</p>
<p>我们也可以通过执行<code>hugo -help</code>查看命令帮助。</p>
<a class="post-dummy-target" id="step-2-create-a-site"></a><h2>Step 2: Create a Site</h2>
<p>创建一个新的hugo站点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo new site path/to/site
</code></pre></td></tr></table>
</div>
</div><p>该命令会在site目录下创建一个新的hugo站点，文件目录结构如下：<br>
site/ <br>
├─ archetypes<br>
│  └─ default.md<br>
├─ config.toml <br>
├─ content<br>
├─ data<br>
├─ layouts<br>
├─ static<br>
└─ themes</p>
<ul>
<li>config.toml<br>
站点的全局参数配置文件</li>
<li>archetypes<br>
存放default.md文件，该文件定义了Hugo的markdown文件<code>前置数据(Front Matter)</code>的结构，可以理解为markdown的metadata。我们可以自定义该结构文件，然后在config.toml中指定自定义的结构文件。Front Matter支持三种格式，分别为yaml，toml和json。默认生成的default.md文件为yaml格式，至少包括以下3项：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-YAML" data-lang="YAML"><span class="w">	</span>--- <span class="w"> 
</span><span class="w">	</span><span class="k">title</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;{{ replace .Name &#34;</span>-<span class="s2">&#34; &#34;</span><span class="w"> </span><span class="s2">&#34; | title }}&#34;</span><span class="w">  
</span><span class="w">	</span><span class="k">date</span><span class="p">:</span><span class="w"> </span>{{<span class="w"> </span>.Date<span class="w"> </span>}}<span class="w">  
</span><span class="w">	</span><span class="k">draft</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  
</span><span class="w">	</span>--- <span class="w"> 
</span></code></pre></td></tr></table>
</div>
</div><p>  <code>draft</code>为<code>true</code>表示该文章处于草稿状态，不会被渲染和显示，发布时需要改为<code>false</code>。</p>
<ul>
<li>
<p>content<br>
存放网页内容的目录，我们编写的markdown文件都存放在该目录中，是Hugo的默认源目录。</p>
</li>
<li>
<p>data<br>
data目录用来存放数据文件，一般是json文件，Hugo提供了相关命令可以从data目录下读取相关的文件数据，然后渲染到HTML页面中，将业务数据与模板分离。</p>
</li>
<li>
<p>layouts<br>
存放自定义的模板文件，Hugo优先使用layouts目录下的模板，未发现再去themes目录下查找。模板是以<code>.html</code>文件指明如何将内容视图渲染为静态页面。<br>
模板包括列表页面、主页、分类模板、partals、单页模板等。</p>
</li>
<li>
<p>static<br>
存放所有的静态内容，如images, css、js、CNAME等。Hugo在渲染时，会将static目录下的文件直接复制到public目录下，不会做任何渲染。</p>
</li>
<li>
<p>themes<br>
存放网站主题，可以下载多个主题，themes目录下的每个子目录代表了一个主题。可以通过在config.toml中通过参数theme指定主题，即theme目录下的子目录名字，也可以在执行hugo命令渲染时通过增加flag参数–theme=xx指定。</p>
</li>
</ul>
<a class="post-dummy-target" id="step-3-add-a-theme"></a><h2>Step 3: Add a Theme</h2>
<p>Hugo允许我们创建自己的主题或者使用预创建的开源主题。使用预创建的主题可以为我们节约大量的时间，避免关注不必要的技术细节而专注于内容的输出。让我们使用预创建的主题快速开始吧！</p>
<p>首先我们挑选一个喜欢的 <a href="https://themes.gohugo.io/" target="_blank"><u>hugo主题</u></a> ，例如 <a href="https://themes.gohugo.io/loveit/" target="_blank"><u>LoveIt</u></a>，然后将主题下载到themes目录下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> path/to/site
git init
git clone https://github.com/xx/xx.git themes/LoveIt
</code></pre></td></tr></table>
</div>
</div><p>执行成功后，会在themesm目录下生成主题目录LoveIt。<br>
添加主题到配置文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s1">&#39;theme = &#34;LoveIt&#34;&#39;</span> &gt;&gt; config.toml
</code></pre></td></tr></table>
</div>
</div><p>或直接用文本编辑器打开config.toml修改相应的配置。</p>
<p>一个快速简便的配置方法是用<code>themes/loveit/exampleSite</code>下的<code>config.toml</code>替换<code>/site</code>站点目录下默认生成的<code>config.tmol</code>。</p>
<a class="post-dummy-target" id="step-4-add-content"></a><h2>Step 4: Add Content</h2>
<p>我们可以手动创建内容文件（content files），然后添加metadata，如title和data等。也可以通过下面的命令自动创建草稿：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo new posts/my-first-post.md
</code></pre></td></tr></table>
</div>
</div><p>在<code>content/posts</code>目录中会生成一篇名为<code>my-first-post.md</code>的文章草稿，并自动添加<code>archetypes/default.md</code>中的内容。</p>
<a class="post-dummy-target" id="step-5-hosting-site-locally"></a><h2>Step 5: Hosting Site Locally</h2>
<p>在站点目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo server
</code></pre></td></tr></table>
</div>
</div><p>启动服务器后，可以通过<a href="http://localhost:1313/" target="_blank">http://localhost:1313/</a>访问站点并调试。Hugo支持所谓的LiveReload，相应配置及内容的修改会即刻生效并在浏览器中加载。</p>
<a class="post-dummy-target" id="step-6-build-static-pages"></a><h2>Step 6: Build Static Pages</h2>
<p>在创建静态页面之前，我们需要对<code>config.toml</code>进行配置。因为我们准备将该网页托管到github pages上，需要将baseURL修改为&quot;https://yourgithubusername.github.io/&quot;。<br>
调试无误后，我们在站点目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">hugo
</code></pre></td></tr></table>
</div>
</div><p>该命令会在站点目录下新建一个public子目录，然后将渲染后的全部站点文件输出到该目录中。<br>
我们可以将public目录中的文件直接提交到github上以Githbu Pages方式发布，也可以部署到自己的服务器上。</p>
<a class="post-dummy-target" id="step-7-hosting-on-github-pages"></a><h2>Step 7: Hosting on Github Pages</h2>
<p>我们在github中新建一个repo，命名为<code>yourgithubusername.github.io</code>，然后将public中的文件push到该仓库中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> path/to/site/public
git init
git remote add origin https://github.com/yourgithubusername/yourgithubusername.github.io
git add.
git commit -m <span class="s2">&#34;your message&#34;</span>
git push origin master
</code></pre></td></tr></table>
</div>
</div><p>叮！ 通过<u><a href="http://yourgitubusername.github.io">http://yourgitubusername.github.io</a></u> 访问你的网站吧。</p>
<a class="post-dummy-target" id="reference"></a><h2>Reference</h2>
<ol>
<li><a href="https://s0gohugo0io.icopy.site/documentation/" target="_blank">Hugo Documentation</a></li>
</ol></div><div class="post-footer">
        <a href="https://belldrum.com/2020/02/0001-hugo-concise-tutorial/">阅读全文</a><div class="post-tags"><span class="tag">
                        &nbsp;<a href="https://belldrum.com/tags/hugo/"><i class="fas fa-tag fa-fw"></i>&nbsp;Hugo</a>
                    </span></div></div>
</article><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-featured-image-preview"><img src="/svg/loading.min.svg" data-sizes="auto" data-src="/yyzt.jpg" alt="featured image" class="lazyload"></div><h1 class="post-title post-list-title" itemprop="name headline">
        <a href="https://belldrum.com/2019/12/0000-foreword/">未至之事，皆为惊喜</a>
    </h1><div class="post-meta"><a class="author" href="https://belldrum.com/" rel="author" target="_blank">
            <i class="fas fa-user-circle fa-fw"></i>嘉文
        </a>发布于  <time datetime=2019-12-31>2019-12-31</time>&nbsp;</div><div class="post-content"><p></p></div><div class="post-footer">
        <a href="https://belldrum.com/2019/12/0000-foreword/">阅读全文</a></div>
</article></div></div>
            </main><footer class="footer">
    <div class="copyright"><div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://belldrum.com/" target="_blank">嘉文</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                <span class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank">鲁ICP备20005030-1</a></span><span class="copyright-line">
				&nbsp;|&nbsp;Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> & <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt</a>
			</span>
		</div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><script src="/js/lib/typeit/typeit.min.js"></script><script>window.typeitArr=[["tp-1bf8abddf514ac940e9ba88fb259fd6a"]];</script><link rel="stylesheet" href="/css/lib/katex/katex.min.css"><script src="/js/lib/katex/katex.min.js"></script><script defer src="/js/lib/katex/auto-render.min.js"></script><link rel="stylesheet" href="/css/lib/katex/copy-tex.min.css"><script defer src="/js/lib/katex/copy-tex.min.js"></script><script defer src="/js/lib/katex/mhchem.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true },{ left: "$", right: "$", display: false },]
            });
        });
    </script><script src="/js/blog.min.js"></script></body>
</html>