<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Server on 晨钟暮鼓</title>
    <link>https://belldrum.com/tags/server/</link>
    <description>Recent content in Server on 晨钟暮鼓</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 28 Feb 2020 00:25:28 +0800</lastBuildDate>
    
	<atom:link href="https://belldrum.com/tags/server/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SSH之原理&amp;实践</title>
      <link>https://belldrum.com/2020/02/0009-ssh-intro2/</link>
      <pubDate>Fri, 28 Feb 2020 00:25:28 +0800</pubDate>
      
      <guid>https://belldrum.com/2020/02/0009-ssh-intro2/</guid>
      <description>&lt;p&gt;OpenSSH是SSH协议的一个免费开源实现，是用于使用SSH协议进行远程登录的主要连接工具。它对所有流量进行加密，以消除窃听、连接劫持等攻击。此外，OpenSSH还提供了一整套安全的隧道功能、多种身份验证方法以及复杂的配置选项。&lt;/p&gt;
&lt;p&gt;OpenSSH软件主要包含以下几种工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器端由SSH服务(sshd)、sftp-server和ssh-agent组成&lt;/li&gt;
&lt;li&gt;客户端使用ssh-keygen、ssh-add、ssh-kyesign、ssh-keyscan等管理密钥&lt;/li&gt;
&lt;li&gt;远程操作使用ssh、scp和sftp完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文主要介绍SSH的工作流程以及OpenSSH部分工具的使用。&lt;/p&gt;
&lt;h2 id=&#34;认证过程&#34;&gt;认证过程&lt;/h2&gt;
&lt;p&gt;SSH 协议使用对称加密(symmetric encryption)，非对称加密(asymmetric encryption)和哈希(hashing)来保证信息传输的安全。客户端和服务器端的SSH连接过程主要包括三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在客户端进行服务器验证&lt;/li&gt;
&lt;li&gt;生成会话密钥(session key)加密所有通信&lt;/li&gt;
&lt;li&gt;客户认证&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;服务器验证&#34;&gt;服务器验证&lt;/h3&gt;
&lt;p&gt;Ssh连接采用客户端-服务器模型(c/s)，客户端首先向服务器发送连接请求，服务器端运行的SSH服务(sshd)默认监听22端口并处理连接请求，这时客户端需要验证服务器的身份。服务器身份验证主要有两种情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首次连接&lt;/strong&gt;&lt;br&gt;
如果客户端是第一次连接服务器，则要求客户端通过验证服务器的公钥来手动认证服务器。服务器的公钥一般保存在&lt;code&gt;/etc/ssh/host_key*&lt;/code&gt;，也可以使用ssh-keyscan命令找到。一旦服务器密钥被接受，那么将会被添加到客户端&lt;code&gt;~/.ssh/know_hosts&lt;/code&gt;文件中。&lt;code&gt; known_hosts&lt;/code&gt;文件包含有关客户端所有已验证服务器的信息。&lt;br&gt;
&lt;strong&gt;2. 再次连接&lt;/strong&gt;&lt;br&gt;
如果客户端不是第一次访问要连接的服务器，则将服务器的身份与&lt;code&gt;known_hosts&lt;/code&gt;文件中先前记录的信息进行匹配以进行验证。&lt;br&gt;
&lt;br /&gt;
服务器的身份需要用户手动进行验证，这样做的目的主要是为了防止中间人攻击(Man-in-the-middle attack, MITM)。&lt;/p&gt;
&lt;h3 id=&#34;生成会话密钥&#34;&gt;生成会话密钥&lt;/h3&gt;
&lt;p&gt;验证服务器后，服务器端和客户端使用&lt;code&gt;Diffie-Hellman&lt;/code&gt;算法生成会话密钥(session key)。 该算法的设计方式是，双方在会话密钥的生成中会做出同等贡献。 生成的会话密钥是在客户端和服务器端共享的对称密钥，即双方使用相同的密钥加密和解密。&lt;/p&gt;
&lt;h3 id=&#34;客户端认证&#34;&gt;客户端认证&lt;/h3&gt;
&lt;p&gt;最后阶段是使用SSH密钥对来验证客户端的身份。顾名思义，SSH密钥对由两个不同目的的密钥组成： 公钥用于加密数据并可以自由分发，私钥用于解密数据，并且永远不会与任何人共享。  对称加密建立后，将对客户端进行身份验证，验证过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端首先向服务器发送要验证的密钥对的ID。&lt;/li&gt;
&lt;li&gt;服务器检查客户端尝试登录的帐户的authorized_keys文件中的密钥ID。&lt;/li&gt;
&lt;li&gt;如果在文件中找到匹配该ID的公钥，那么服务器将生成一个随机数，然后使用客户端公钥对随机数进行加密并将加密的消息发送给客户端。&lt;/li&gt;
&lt;li&gt;如果客户端拥有正确的私钥，它将解密该消息以获得服务器生成的随机数。&lt;/li&gt;
&lt;li&gt;客户端将获得的随机数与共享的会话密钥结合在一起，并计算该值的MD5哈希值。&lt;/li&gt;
&lt;li&gt;然后，客户端将此MD5哈希发送回服务器，作为对加密号码消息的答复。&lt;/li&gt;
&lt;li&gt;服务器使用相同的共享会话密钥和发送给客户端的原始号码自行计算MD5值。它将自己的计算结果与客户端发回的计算结果进行比较。如果这两个值匹配，则证明该客户端拥有私钥，并且该客户端已通过身份验证。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不对称密钥允许服务器对客户端进行身份验证，因为客户端只有在拥有正确的关联私钥的情况下才能解密消息。&lt;br&gt;
此外，SSH支持多种身份验证机制，最常见的是&lt;strong&gt;密码认证&lt;/strong&gt;和&lt;strong&gt;公钥认证&lt;/strong&gt;。上文只说明了公钥认证过程，当公钥认证未通过时，会再进行密码认证，此处不再赘述。&lt;/p&gt;
&lt;h2 id=&#34;对称加密&#34;&gt;对称加密&lt;/h2&gt;
&lt;p&gt;我们在前文中介绍过，SSH 协议使用对称加密(symmetric encryption)，非对称加密(asymmetric encryption)和哈希(hashing)来保证信息传输的安全。&lt;br&gt;
大部分教程对非对称密钥的作用有详细的介绍，但在对称密钥介绍时往往语焉不详，造成很多人的误解。本节主要是希望大家了解一点，&lt;strong&gt;SSH使用对称密钥来加密整个连接，非对称密钥仅用于身份验证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对称加密是一种加密类型，使用同一个密钥加密发给对方的消息、解密从另一方收到的消息。这意味着拥有密钥的任何人都可以加密和解密发送给拥有密钥的其他人的消息。这种加密模式通常称为“shared secret”加密或“secret key”加密。通常，只有一个密钥用于所有操作，或者只有一对密钥，它们之间的关系很容易发现，或者很容易根据一个密钥推导出另一个密钥。&lt;/p&gt;
&lt;p&gt;SSH使用对称密钥来加密整个连接。与一些人的假设相反，我们创建的公有/私有非对称密钥对仅用于身份验证，而不用于加密连接。对称加密甚至可以保护密码验证免遭监听。&lt;/p&gt;
&lt;p&gt;客户端和服务端为生成对称密钥做出了同等的贡献，并且最终生成的密钥永远不会为外界所知。这个密钥是通过密钥交换算法创建的，这种算法允许服务器和客户端共享某些公共数据，然后使用各自保留的秘密数据进行处理，最终两者独立地到达相同的目的：生成同一密钥。更详细地说明可参考这篇&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;通过此过程创建的对称加密密钥是基于会话的(session-bassed)，并且构成了服务器与客户端之间发送的数据的实际加密。一旦建立，必须使用此共享密钥对其余数据进行加密。这个阶段完成之后，服务端和客户端的加密会话就被建立了，然后开始进行客户端的验证。&lt;/p&gt;
&lt;p&gt;SSH可以使用多种对称密码系统，包括AES，Blowfish，3DES，CAST128和Arcfour等。服务器和客户端都可以决定其支持的密码列表，按优先顺序排序。最终两者进行协商，客户端列表中的第一个在服务器上可用的选项将被用作两个方向上的加密算法。&lt;/p&gt;
&lt;h2 id=&#34;文件介绍&#34;&gt;文件介绍&lt;/h2&gt;
&lt;p&gt;SSH密钥验证过程涉及客户端和服务器端的多个文件，为了避免混淆，我们来总结一下各个文件的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;br&gt;
ssh服务程序(sshd)的配置文件&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etc/ssh/ssh_host_*&lt;/code&gt;&lt;br&gt;
ssh服务程序(sshd)启动时自动生成的服务端公钥和私钥文件，也可以通过&lt;code&gt;dpkg-reconfigure openssh-server&lt;/code&gt;命令重新生成。共有八个文件，包括四种加密类型：&lt;code&gt;rsa&lt;/code&gt;、&lt;code&gt;dsa&lt;/code&gt;、&lt;code&gt;ecdsa&lt;/code&gt;和&lt;code&gt;ed25519&lt;/code&gt;（实际使用时服务器会选择其中一种加密类型）。其中&lt;code&gt;.pub&lt;/code&gt;结尾的是公钥，将写入到客户端的&lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;文件中，用于验证服务器身份。&lt;br&gt;
其中私钥文件严格要求权限为600，若不是则sshd服务可能会拒绝启动。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;&lt;br&gt;
保存的是基于公钥认证机制时客户端用户的公钥。在进行客户端认证时，服务端将读取对应用户目录下的&lt;code&gt;authorized_keys&lt;/code&gt;文件。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/ssh_config&lt;/code&gt;&lt;br&gt;
客户端的全局配置文件。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/config&lt;/code&gt;&lt;br&gt;
客户端的用户配置文件，生效优先级高于全局配置文件。一般该文件默认不存在，可自行创建。该文件对权限有严格要求，只对所有者有读/写权限，对其他人完全拒绝写权限。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;&lt;br&gt;
保存服务器验证时服务端&lt;code&gt;host key&lt;/code&gt;的文件，文件内容来源于服务端的&lt;code&gt;ssh_host_*_key.pub&lt;/code&gt;文件。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/known_hosts&lt;/code&gt;&lt;br&gt;
全局&lt;code&gt;host key&lt;/code&gt;保存文件，作用等同于&lt;code&gt;~/.ssh/known_hosts&lt;/code&gt;。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/id_rsa&lt;/code&gt;&lt;br&gt;
客户端生成的私钥。由ssh-keygen生成。该文件严格要求权限，文件权限不得大于&lt;code&gt;711&lt;/code&gt;，一般设置为&lt;code&gt;600&lt;/code&gt;。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&lt;br&gt;
私钥&lt;code&gt;id_rsa&lt;/code&gt;的配对公钥。对权限不敏感。当采用公钥认证机制时，该文件内容需要提前复制到服务端的&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;文件中。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.ssh/rc&lt;/code&gt;&lt;br&gt;
保存的是命令列表，这些命令在ssh连接到远程主机成功时将第一时间执行，执行完这些命令之后才开始登陆或执行ssh命令行中的命令。&lt;br&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/ssh/rc&lt;/code&gt;&lt;br&gt;
作用等同于&lt;code&gt;~/.ssh/rc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;
配置文件主要包括服务端配置文件&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;和客户端配置文件&lt;code&gt;/etc/ssh/ssh_config&lt;/code&gt;。这两个文件中有很多同名的配置项，但前者是sshd启动时开关性的设置，后者是请求连接时客户端采取的配置。例如，两配置文件都有GSSAPIAuthentication项，在客户端将其设置为no，表示连接时将直接跳过该身份验证机制，而在服务端设置为no则表示sshd启动时不开启GSSAPI身份验证的机制。即使客户端使用了GSSAPI认证机制，只要服务端没有开启，就绝对不可能认证通过。&lt;/p&gt;
&lt;h2 id=&#34;认证实现&#34;&gt;认证实现&lt;/h2&gt;
&lt;p&gt;前文介绍了公钥认证的过程以及涉及到的文件，接下来主要介绍公钥认证的具体实现步骤。&lt;br&gt;
公钥认证过程主要包括两个步骤：1)生成密钥对和 2)分发公钥。&lt;/p&gt;
&lt;h3 id=&#34;生成密钥对&#34;&gt;生成密钥对&lt;/h3&gt;
&lt;p&gt;OpenSSH提供了密钥生成工具ssh-keygen。我们在客户端（服务端也行，无所谓在哪生成）执行&lt;code&gt;ssh-keygen&lt;/code&gt;指令会出现如下提示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh-keygen -t rsa 	&lt;span class=&#34;c1&#34;&gt;#-t参数指定算法，通常使用rsa或dsa&lt;/span&gt;
Generating public/private rsa key pair.
Enter file in which to save the key &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;/root/.ssh/id_rsa&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:  &lt;span class=&#34;c1&#34;&gt;# 输入密钥对保存路径，与-f参数作用相同&lt;/span&gt;
Enter passphrase &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;empty &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; no passphrase&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:               &lt;span class=&#34;c1&#34;&gt;# 输入私钥密码，可留空，与-P参数作用相同&lt;/span&gt;
Enter same passphrase again:            
Your identification has been saved in /root/.ssh/id_rsa. 
Your public key has been saved in /root/.ssh/id_rsa.pub. 
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如不指定保存路径，那么生成的密钥对默认保存在&lt;code&gt;~/.ssh/&lt;/code&gt;目录下。其中，私钥的权限设置为&lt;code&gt;600&lt;/code&gt;，如果权限过大会导致公钥认证失败。&lt;/p&gt;
&lt;h3 id=&#34;分发公钥&#34;&gt;分发公钥&lt;/h3&gt;
&lt;p&gt;密钥生成后，我们要将公钥发送到远程服务器对应用户的家目录下，可以使用&lt;code&gt;ssh-copy-id&lt;/code&gt;命令实现，语法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh-copy-id &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-i &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;identity_file&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;user@&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;host
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;-i 指定要分发的公钥文件&lt;/li&gt;
&lt;li&gt;user 指定对应的用户名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子，我们将公钥分发到服务器&lt;code&gt;114.55.93.224&lt;/code&gt;上的&lt;code&gt;gavin&lt;/code&gt;用户家目录下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh-copy-id -i .ssh/id_rsa.pub gavin@114.55.93.224
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;而如果ssh服务端的端口不是22，还需要给&lt;code&gt;ssh-copy-id&lt;/code&gt;传递端口号，格式为&lt;code&gt;&amp;quot;-p port_num [user@]hostname&amp;quot;&lt;/code&gt;，如 &lt;code&gt;&amp;quot;-p 2222 gavin@114.55.93.224&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh-copy-id&lt;/code&gt;命令的作用是在目标主机的指定用户的家目录下，检测是否有&lt;code&gt;~/.ssh&lt;/code&gt;目录，如果没有，则以700权限创建该目录，然后将本地的公钥追加到目标主机指定用户家目录下的&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;文件中。&lt;code&gt;authorized_keys&lt;/code&gt;文件可以保存多个公钥信息，每个公钥以换行分开。&lt;br&gt;
&lt;br /&gt;
因此，我们也可以直接将公钥文件传输到服务器上，然后手动将公钥追加到对应用户家目录下的&lt;code&gt;.ssh/authorized_keys&lt;/code&gt;文件中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cat id_rsa &amp;gt;&amp;gt; authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;公钥分发完成后，我们就可以远程连接服务器了。&lt;/p&gt;
&lt;h2 id=&#34;最佳实践&#34;&gt;最佳实践&lt;/h2&gt;
&lt;h3 id=&#34;更改默认端口&#34;&gt;更改默认端口&lt;/h3&gt;
&lt;p&gt;Linux默认使用22端口进行远程登录，一些人专门用服务器扫描22端口并使用弱口令等进行暴力破解，通过更改22端口可以过滤掉大部分暴力破解的访问。&lt;br&gt;
&lt;ruby&gt;&lt;rb&gt;SSH服务&lt;/rb&gt;&lt;rt&gt;ssh daemon&lt;/rt&gt;&lt;/ruby&gt;是OpenSSH软件套件中运行在服务器端的守护进程，它的配置文件是&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，在配置文件中可以修改守护进程监听的端口。&lt;/p&gt;
&lt;p&gt;在修改之前我们先对配置文件进行备份，然后用文本编辑工具打开：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
vim /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;打开后可以看到如下内容：&lt;/p&gt;
&lt;pre&gt;
	#	$OpenBSD: sshd_config,v 1.101 2017/03/14 07:19:07 djm Exp $

	# This is the sshd server system-wide configuration file.  See
	# sshd_config(5) for more information.

	# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

	# The strategy used for options in the default sshd_config shipped with
	# OpenSSH is to specify options with their default value where
	# possible, but leave them commented.  Uncommented options override the
	# default value.

	#Port 22
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
&lt;/pre&gt;
&lt;p&gt;其中22端口被注释掉了。&lt;br&gt;
为了防止后续端口修改错误导致无法登录，我们先删除&lt;code&gt;#&lt;/code&gt;保留&lt;code&gt;Port 22&lt;/code&gt;端口，然后另起一行添加&lt;code&gt;Port 2222&lt;/code&gt;，修改后的文件如下：&lt;/p&gt;
&lt;pre&gt;
	Port 22
	Port 2222
	#AddressFamily any
	#ListenAddress 0.0.0.0
	#ListenAddress ::
&lt;/pre&gt;
&lt;p&gt;修改完成后我们保存退出，重启sshd服务使配置生效：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;systemctl restart sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;或&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;service sshd restart
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;重启完成后，我们可以通过&lt;code&gt;netstat -ntl&lt;/code&gt;或&lt;code&gt;ss -ntl&lt;/code&gt;命令查看一下端口。&lt;/p&gt;
&lt;p&gt;配置完成后，记得在防火墙和安全组中放行&lt;code&gt;2222&lt;/code&gt;端口，然后用新端口重新登录。&lt;br&gt;
如果登录成功，测试正常后，我们就可以注释或删除掉之前保留的&lt;code&gt;22&lt;/code&gt;端口了。&lt;/p&gt;
&lt;h3 id=&#34;禁止root登录&#34;&gt;禁止root登录&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;
PermitRootLogin yes			# 是否允许root用户登录，默认为yes
&lt;/pre&gt;
&lt;h3 id=&#34;禁止口令登录&#34;&gt;禁止口令登录&lt;/h3&gt;
&lt;p&gt;修改&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;
PasswordAuthentication yes		# 是否使用密码验证，默认为yes，如果使用密钥对验证可以关闭
&lt;/pre&gt;
&lt;h3 id=&#34;待补充&#34;&gt;待补充&lt;/h3&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/understanding-the-ssh-encryption-and-connection-process&#34; target=&#34;_blank&#34;&gt;Understanding the SSH Encryption and Connection Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@Magical_Mudit/understanding-ssh-workflow-66a0e8d4bf65&#34; target=&#34;_blank&#34;&gt;Understanding SSH workflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/f-ck-need-u/p/7129122.html&#34; target=&#34;_blank&#34;&gt;SSH命令和SSH服务详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>阿里ECS实例配置</title>
      <link>https://belldrum.com/2020/02/0003-ali-cloud-server/</link>
      <pubDate>Wed, 12 Feb 2020 19:48:57 +0800</pubDate>
      
      <guid>https://belldrum.com/2020/02/0003-ali-cloud-server/</guid>
      <description>&lt;p&gt;趁着过年期间阿里云的新客活动，忍痛购买了3年的ECS云服务器，顺便可以给自己的域名挂上良民证，奥利给！&lt;/p&gt;
&lt;p&gt;但是由于今年疫情的原因，备案时间会比较长，据说需要20天左右。而且之前一直只是在用Linux Client，于是趁着备案期间先熟悉一下阿里云Linux Server的使用和设置，下面是一些零零散散的踩坑记录。&lt;/p&gt;
&lt;h2 id=&#34;密码&#34;&gt;密码&lt;/h2&gt;
&lt;p&gt;管理密码是一件非常头疼的事情，每次设置完密码都会陷入沉思，&amp;ldquo;woc&amp;hellip;马什么梅来?&amp;quot;。&lt;br&gt;
ECS实例创建后主要使用的有两个密码，分别是实例密码和远程连接密码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例密码&lt;br&gt;
实例密码是Linux操作系统的密码，就是Root用户密码。奇怪的是创建实例时没有任何初始密码的提示，我是在创建完成后在服务控制台进行的密码重置，需要注意的是重置密码需要重启实例后才会生效。&lt;/li&gt;
&lt;li&gt;远程连接密码&lt;br&gt;
远程连接密码是指阿里云控制台自带的远程连接工具的密码，这个密码最初是系统自动生成的6位数字，用户可以自定义修改这个远程连接密码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，如果我们不使用阿里云控制台自带的VNC远程连接工具，那么就用不到远程连接密码。更改远程连接密码无需重启直接生效；实例密码是Linux系统下的root密码，Windows系统下的administrator密码，修改实例密码必须重启实例才可以生效。&lt;/p&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;阿里云面向客户提供的网络类型服务有经典网络和专有网络两种，官方文档给的解释是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经典网络&lt;br&gt;
ip地址由阿里云统一分配，配置简便，使用方便，适合对操作易用性要求比较高、需要快速使用 ECS 的用户。&lt;/li&gt;
&lt;li&gt;专有网络&lt;br&gt;
是指逻辑隔离的私有网络，您可以自定义网络拓扑和 ip 地址，支持通过专线连接。适合于熟悉网络管理的用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们通俗点理解就是，经典网络和专有网络公网使用同一个公网ip。但是从内网ip来看，经典网络是DHIP，也就是系统自动分配局域网ip地址，而专有网络则是手动分配局域网ip地址，方便有多台云服务器的用户自行定义内网ip结构。所以，如果我们只有一台服务器，或者有多台服务器但不需要进行内网互联，那么这两种网络任选一个就可以了。官方推荐使用专有网络。&lt;/p&gt;
&lt;h2 id=&#34;带宽&#34;&gt;带宽&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;入网带宽（上行带宽）&lt;br&gt;
流入云服务器ECS的带宽，例如：
&lt;ul&gt;
&lt;li&gt;云服务器ECS下载外部网络资源&lt;/li&gt;
&lt;li&gt;FTP客户端上传资源到云服务器ECS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出网带宽（下行带宽）&lt;br&gt;
流出云服务器ECS的带宽，例如：
&lt;ul&gt;
&lt;li&gt;云服务器ECS对外提供访问&lt;/li&gt;
&lt;li&gt;FTP客户端下载云服务器ECS内部资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安全组&#34;&gt;安全组&lt;/h2&gt;
&lt;p&gt;安全组是ECS实例的虚拟防火墙，用于设置实例的网络访问控制，允许或拒绝公网请求和内网请求。&lt;br&gt;
安全组具备状态检测和数据包过滤功能，可以设置单台或多台云服务器的网络访问控制。&lt;br&gt;
&lt;br /&gt;
每个实例必须属于至少一个安全组，一个安全组可以包括多个实例。同一安全组内的实例之间默认内网互通，不同安全组的实例之间默认内网不通，可以授权两个安全组之间互访。&lt;br&gt;
在创建实例时，系统会提供一个默认安全组，默认安全组中的默认规则仅设置针对ICMP协议、SSH 22端口、RDP 3389端口、HTTP 80端口和HTTPS 443端口的入方向规则。&lt;br&gt;
&lt;br /&gt;
我们也可以自行创建一个安全组并添加满足自己业务需求的安全组规则，自行创建的安全组在未添加任何安全组规则之前，出方向允许所有访问，入方向拒绝所有访问。&lt;/p&gt;
&lt;h3 id=&#34;添加规则&#34;&gt;添加规则&lt;/h3&gt;
&lt;p&gt;一般场景下我们需要设置的选项主要有两个：端口范围和授权对象，其他可参考默认设置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口范围&lt;br&gt;
端口取值范围从1到65535，设置格式例如1/200或者80/80，其中“-1/-1”不能单独设置，代表不限制端口。&lt;/li&gt;
&lt;li&gt;授权对象&lt;br&gt;
可以填写单个ip地址，例如223.78.253.196/32，填写0.0.0.0/0表示允许/拒绝全网段访问指定端口。&lt;br&gt;
可以填写多个ip地址，彼此之间用逗号隔开。&lt;br&gt;
此外还可以指定ip地址段，如 223.78.253.196/31，这将会授权/拒绝223.78.253.196和223.78.253.197的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;规则优先级&#34;&gt;规则优先级&lt;/h3&gt;
&lt;p&gt;同类型规则间依赖优先级（手动建立1-100，系统建立110）决定最终执行的规则。当ECS实例加入了多个安全组时，多个安全组会从高到低依次匹配规则。优先级取值范围如下所示，数值越小，优先级越高。&lt;/p&gt;
&lt;h3 id=&#34;实践建议&#34;&gt;实践建议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;仅允许少量请求访问ECS实例时，可以将安全组作为白名单使用。即先设置安全组为拒绝全部访问，然后逐一添加允许通信的访问请求策略。&lt;/li&gt;
&lt;li&gt;选择开放具体的端口，如80/80端口，不要设置为端口范围。&lt;/li&gt;
&lt;li&gt;添加安全组规则时，谨慎授权0.0.0.0/0（全网段）访问源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一个例子&#34;&gt;一个例子&lt;/h3&gt;
&lt;p&gt;如果您在实例上架设了一个网站，希望您的用户能通过HTTPS服务访问到您的网站，您需要在实例所在安全组中添加以下安全组规则。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;网络类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;网卡类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;规则方向&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;授权策略&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;协议类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;端口范围&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;授权类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;授权对象&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;优先级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;VPC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不需要配置&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;入方向&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;允许&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HTTPS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;443&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;地址段访问&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.0.0.0/0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;经典网络&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;公网&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;入方向&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;允许&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HTTPS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;443&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;地址段访问&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.0.0.0/0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;远程连接&#34;&gt;远程连接&lt;/h2&gt;
&lt;p&gt;Secure Shell（SSH）是一种加密网络协议，通过对传输内容进行加密在不安全的网络上安全地操作网络服务，常用于用户远程登录到计算机系统，详细请戳&lt;a href=&#34;https://belldrum.com/2020/02/0009-ssh-intro2/&#34; target=&#34;_blank&#34;&gt;「SSH 原理 &amp;amp; 实践」&lt;/a&gt;。&lt;br&gt;
&lt;br /&gt;
连接之前我们需要确认安全组中已开放22端口，确认之后我们可以通过用户名密码验证和SSH密钥对验证两种方式远程连接服务器实例。密钥验证相对更加安全，而且阿里云密钥验证的设置也非常简便，直接在控制台中即可一键完成，因此我们推荐使用密钥认证的方式连接服务器。&lt;br&gt;
&lt;br /&gt;
首先在 &lt;code&gt;云服务控制台 &amp;gt; 网络与安全 &amp;gt; 密钥对&lt;/code&gt; 中创建密钥对并绑定实例，该密钥由ECS生成，默认采用RSA 2048位的加密方式。密钥绑定后，公钥会自动分发给绑定的实例，我们只需要把私钥保存到本地，然后便可通过XShell等工具连接实例了。&lt;br&gt;
&lt;br /&gt;
绑定和解绑密钥时需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用SSH密钥对登录Linux实例，将会禁用密码登录，以提高安全性。&lt;br&gt;
如果在绑定密钥对之后想使用密码方式登录实例，可以通过重置实例密码实现。如果在绑定密钥对之后重置了实例密码，使用密钥对方式和使用密码方式均能登录实例。&lt;/li&gt;
&lt;li&gt;基于数据安全考虑，在实例状态为运行中（Running）时绑定或者解绑密钥对，我们需要重启实例使操作生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;防火墙&#34;&gt;防火墙&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特别提醒&lt;/strong&gt;&lt;br&gt;
&lt;u&gt;远程使用ufw注意开启远程连接的端口，或者在测试时设置定时关闭防火墙的脚本，防止自己连接不上&lt;/u&gt;&lt;br&gt;
&lt;br /&gt;
UFW，即&lt;ruby&gt;&lt;rb&gt;简单防火墙&lt;/rb&gt;&lt;rt&gt;uncomplicated firewall&lt;/rt&gt;&lt;/ruby&gt;，是Ubuntu下的一个简易防火墙配置工具。&lt;br&gt;
UFW是iptables的前端，简化了iptables复杂的配置过程，使用起来很方便。默认情况下UFW是没有开启的，我们通过以下命令可以启动UFW：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt;
ufw default deny
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中第一条命令是启动ufw，并设置为开机启动；第二条命令是使用ufw默认的规则，即关闭所有的外部对本机的访问，但本机访问外部正常。&lt;br&gt;
我们也可以关闭ufw和开机启动，命令如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw disable
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用allow命令打开指定的端口，举个例子，我们打开22和80端口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw allow &lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;
ufw allow &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;指定允许来自某一个ip或网段的连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw allow from 192.168.1.1/24
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用&lt;code&gt;delete allow&lt;/code&gt;删除已经添加过的规则，举个例子，我们禁用80端口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw delete allow &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;规则设置完成后，我们可以重新加载来使规则生效（不重新加载也会生效?），命令如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw reload
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;现在可以通过以下命令查看防火墙的状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw status
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们配置了很多规则，但是现在需要抛弃它们重新配置，我们可以这么做：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ufw reset
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;更多配置选项可以参考UFW手册 &lt;code&gt;man ufw&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>